<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Tallon</title>
  
  <subtitle>Hello World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tallon.ink/"/>
  <updated>2020-04-25T16:53:13.033Z</updated>
  <id>https://tallon.ink/</id>
  
  <author>
    <name>Tallon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud Alibaba Dubbo</title>
    <link href="https://tallon.ink/archives/6bafcd40.html"/>
    <id>https://tallon.ink/archives/6bafcd40.html</id>
    <published>2020-04-25T03:02:51.000Z</published>
    <updated>2020-04-25T16:53:13.033Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>搭建一套基于 Spring Cloud Alibaba 和 Dubbo 的脚手架，<br>集成 MybatisPlus 等常用中间件，<br>实现对内 RPC、对外 Rest 的能力</p>          </div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>将 Dubbo 融入到 Spring Cloud Alibaba 生态中， 使微服务之间的调用同时具备 RESTful 和 Dubbo 调用的能力。 做到对业务代码无侵入，无感知； 引入 JAR 包则微服务间调用使用 Dubbo，去掉 JAR 包则使用默认的 RESTful；<br>实现参考的是 Spring Cloud 中文社区的 Spring Cloud Dubbo 项目。<br>对内 RPC 进行资源调用，速度远比 http 请求快得多，少了一次正反序列化的过程<br>（rpc 1次，http 2次）。<br>既然使用 Cloud Alibaba，故使用 nacos 来做 Dubbo 的注册中心。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>基于Docker启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nacos-group/nacos-docker.git</span><br><span class="line">cd nacos-docker</span><br><span class="line">docker-compose -f example/standalone-mysql-8.yaml up -d</span><br></pre></td></tr></table></figure><br>如果mac本地的docker，需要share数据卷example<br>账号：nacos 密码：nacos</p><blockquote><p>目前是单机模式，后期可以改进成高可用集群版 K8S-nacos</p></blockquote><h2 id="未完待续···"><a href="#未完待续···" class="headerlink" title="未完待续···"></a>未完待续···</h2>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;搭建一套基于 Spring Cloud Alibaba 和 Dubbo 的脚手架，&lt;br&gt;集成 MybatisPlus 等常用中间件，&lt;br&gt;实现对内 RPC、对外 Rest 的能力&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="框架" scheme="https://tallon.ink/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="https://tallon.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>写好代码</title>
    <link href="https://tallon.ink/archives/ab95a53b.html"/>
    <id>https://tallon.ink/archives/ab95a53b.html</id>
    <published>2019-12-04T17:19:25.000Z</published>
    <updated>2020-07-17T08:20:29.945Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>开发这两年，尤其写多了各种又臭又长的复杂业务代码后，<br>越来越意识到能写出一份让自己再看时满意、同事评审时不骂街的代码，有多难。</p>          </div><a id="more"></a><p>为了做好一个在代码上不将就的初级码农，翻看了多遍 <strong>阿里</strong>的《Java开发手册》和 <strong>Martin Fowler</strong> 的 《重构·改善既有代码的设计》等相关开发理念的书籍。</p><h3 id="十二要素原则"><a href="#十二要素原则" class="headerlink" title="十二要素原则"></a>十二要素原则</h3><p>由 Heroku 云平台的创建者所编写的一套应用程序开发理论，用于描述利用现代云平台来实际构建 SaaS 应用程序的一份宣言。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>使用声明的方式来搭建自动化环境，最大限度的减少新加入项目的开发人员的时间和成本</li><li>与底层操作系统之间建立清晰的约定，在执行环境之间提供最大的可移植性</li><li>适合部署在现代云平台上，无需提供服务器和系统管理工具</li><li>最大程度减少开发环境和生产环境之间的区别，通过持续部署获得最大的灵活性</li><li>可以在不对工具、架构或开发时间带来的重大变动的前提下，进行水平扩展</li></ul><h4 id="程序实践"><a href="#程序实践" class="headerlink" title="程序实践"></a>程序实践</h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">代码库</td><td style="text-align:center">一份版本控制下的基准代码库，多份部署</td></tr><tr><td style="text-align:center">罚恶</td><td style="text-align:center">显式声明和隔离依赖关系</td></tr><tr><td style="text-align:center">配置</td><td style="text-align:center">在环境中存储配置</td></tr><tr><td style="text-align:center">后端服务</td><td style="text-align:center">把后端服务当作附加资源</td></tr><tr><td style="text-align:center">构建、发布、运行</td><td style="text-align:center">严格分离构建和运行阶段</td></tr><tr><td style="text-align:center">进程</td><td style="text-align:center">将应用程序作为一个或多个无状态进程执行</td></tr><tr><td style="text-align:center">端口绑定</td><td style="text-align:center">通过端口绑定暴露服务</td></tr><tr><td style="text-align:center">并发</td><td style="text-align:center">通过进程模型进行扩展</td></tr><tr><td style="text-align:center">易处理</td><td style="text-align:center">通过快速启动和正常关机来最大限度的提高健壮性</td></tr><tr><td style="text-align:center">开发/生产环境一致</td><td style="text-align:center">尽可能的保持开发、预发布和生产环境的配置一致</td></tr><tr><td style="text-align:center">日志</td><td style="text-align:center">将日志视为事件流</td></tr><tr><td style="text-align:center">管理进程</td><td style="text-align:center">将管理任务作为一次性进程运行</td></tr></tbody></table></div><h3 id="阿里重构实例"><a href="#阿里重构实例" class="headerlink" title="阿里重构实例"></a>阿里重构实例</h3><p>今天有幸读到了阿里专家对于“如何写复杂业务代码”的方法论，收益颇丰，故以此记录，方便日后时常回忆。</p><p>目前我司的云原生项目全方面向阿里看齐，虽然学的似是而非，但已经是不错的项目设计。主要负责 <strong>S2B2C</strong> 业务的开展，阿里在业内是最好的学习榜样。</p><p>在第一阶段，零售通是给线下小店供货的 B2B 模式，我们希望通过数字化重构传统供应链渠道，提升供应链效率，为新零售助力。阿里在中间是一个平台角色，提供的是 B2b 中的 service 的功能。<br><img src="https://mrtallon.gitee.io/img/code01.jpg" alt="code01"><br>在商品域，运营会操作一个“上架”动作，上架之后，商品就能在零售通上面对小店进行销售了。<strong>是零售通业务非常关键的业务操作之一，因此涉及很多的数据校验和关联操作。</strong><br><img src="https://mrtallon.gitee.io/img/code02.jpg" alt="code02"></p><h4 id="过程分解"><a href="#过程分解" class="headerlink" title="过程分解"></a>过程分解</h4><p>对于如此复杂的业务逻辑，首先想到的是分治。<br>对于业务分解也会遇到一个问题：过度依赖工具或者辅助手段，自制的流程引擎或者数据库配置的流程处理。<br>本质上来讲，这些辅助手段做的都是一个 pipeline 的处理流程，没有其它。因此，建议此处最好保持 KISS(Keep It Simple and Stupid)，即最好是什么工具都不要用，次之是用一个极简的 Pipeline 模式，最差是使用像流程引擎这样的重方法。<br>商品上架的核心是如何<strong>分解问题</strong>和<strong>抽象问题</strong>，将业务解构出有层级的金字塔结构：<br><img src="https://mrtallon.gitee.io/img/code03.jpg" alt="code03"><br>因此，该程序的入口是一个上架命令(OnSaleCommand), 它由三个阶段(Phase) 组成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Command</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSaleNormalItemCmdExe</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(OnSaleNormalItemCmd cmd)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        OnSaleContext onSaleContext = init(cmd);</span><br><span class="line">        </span><br><span class="line">        checkData(onSaleContext);</span><br><span class="line"></span><br><span class="line">        process(onSaleContext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response.buildSuccess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> OnSaleContext <span class="title">init</span><span class="params">(OnSaleNormalItemCmd cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onSaleContextInitPhase.init(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkData</span><span class="params">(OnSaleContext onSaleContext)</span> </span>&#123;</span><br><span class="line">        onSaleDataCheckPhase.check(onSaleContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(OnSaleContext onSaleContext)</span> </span>&#123;</span><br><span class="line">        onSaleProcessPhase.process(onSaleContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Phase又可以拆解成多个步骤(Step)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Phase</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSaleProcessPhase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(OnSaleContext onSaleContext)</span></span>&#123;</span><br><span class="line">        SupplierItem supplierItem = onSaleContext.getSupplierItem();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成OfferGroupNo</span></span><br><span class="line">        generateOfferGroupNo(supplierItem);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 发布商品</span></span><br><span class="line">        publishOffer(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前后端库存绑定 backoffer域</span></span><br><span class="line">        bindBackOfferStock(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步库存路由 backoffer域</span></span><br><span class="line">        syncStockRoute(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置虚拟商品拓展字段</span></span><br><span class="line">        setVirtualProductExtension(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发货保障打标 offer域</span></span><br><span class="line">        markSendProtection(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录变更内容ChangeDetail</span></span><br><span class="line">        recordChangeDetail(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步供货价到BackOffer</span></span><br><span class="line">        syncSupplyPriceToBackOffer(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是组合商品打标，写扩展信息</span></span><br><span class="line">        setCombineProductExtension(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去售罄标</span></span><br><span class="line">        removeSellOutTag(offerId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送领域事件</span></span><br><span class="line">        fireDomainEvent(supplierItem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭关联的待办事项</span></span><br><span class="line">        closeIssues(supplierItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过分析需求，结构化分解，合理的抽象后，上架这个复杂的流程不需要流程引擎，不需要复杂的设计模式，只是通过朴素的组合方法模式（Composed Method）即完整清晰的罗列出所有业务。<br><img src="https://mrtallon.gitee.io/img/code04.jpg" alt="code04"></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li>知识领域被肢解<ul><li>所有步骤都是过程化拆解，没有一个聚合领域知识的地方，每个 Case 只关心自己的处理流程，，知识没有沉淀</li><li>相同的业务逻辑会在多个 Case 中被重现，导致代码重复度高，复用能力较低，</li><li>代码对业务语义的表达能力很弱，从而影响代码的可读性和可理解性</li></ul></li><li>代码的业务表达能力缺失<ul><li>因为缺失了模型，和模型间的关系，导致很难通过代码显性化的表达业务，缺少代码的韵律和灵魂</li></ul></li></ol><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p><strong>过程分解 + 对象模型</strong><br>有过程分解要好于没有分解，过程分解 + 对象模型要好于仅仅是过程分解。对于商品上架这个case，如果采用过程分解 + 对象模型的方式，最终我们会得到一个如下的系统结构：<br><img src="https://mrtallon.gitee.io/img/code05.jpg" alt="code05"></p><h4 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h4><ul><li>自上而下的结构化分解</li><li>自下而上的面向对象分析</li></ul><h5 id="上下结合"><a href="#上下结合" class="headerlink" title="上下结合"></a>上下结合</h5><p><strong>结合自上而下的过程分解和自下而上的对象建模，螺旋式的构建我们的应用系统。</strong>这是一个动态的过程，两个步骤可以交替进行、也可以同时进行。<br><img src="https://mrtallon.gitee.io/img/code06.jpg" alt="code06"></p><h5 id="能力下沉"><a href="#能力下沉" class="headerlink" title="能力下沉"></a>能力下沉</h5><p>一般来说实践DDD有两个过程：</p><ol><li>套概念阶段了解了一些DDD的概念，然后在代码中“使用”Aggregation Root，Bounded Context，Repository 等等这些概念。更进一步，也会使用一定的分层策略。然而这种做法一般对复杂度的治理并没有多大作用。</li><li>融会贯通阶段术语已经不再重要，理解 DDD 的本质是统一语言、边界划分和面向对象分析的方法。</li></ol><p>目前阶段，不强求一次就能设计出 Domain 的能力，也不需要强制要求把所有的业务功能都放到 Domain 层，而是采用实用主义的态度，即只对那些需要在多个场景中需要被复用的能力进行抽象下沉，而不需要复用的，就暂时放在 App 层的 Use Case 里就好了。<br><strong>模型不是一次性设计出来的，而是迭代演化出来的</strong><br><img src="https://mrtallon.gitee.io/img/code07.jpg" alt="code07"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>身处云原生项目组，当采用 DDD 模式时，即成为了业务技术型开发。<br>业务所面临的复杂性并不亚于底层技术，要想写好业务代码也不是一件容易的事情。业务技术和底层技术人员唯一的区别是他们所面临的问题域不一样。<br>因此，需要培养<strong>分解问题的能力，抽象思维，结构化思维</strong>等等。</p><p>对自己的代码保持怀疑态度，能够使你发现更本质的逻辑！</p><blockquote><p>参考文章：<a href="https://www.zhihu.com/org/a-li-yun-guan-wang-90/activities" target="_blank" rel="noopener">阿里云官网</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;开发这两年，尤其写多了各种又臭又长的复杂业务代码后，&lt;br&gt;越来越意识到能写出一份让自己再看时满意、同事评审时不骂街的代码，有多难。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://tallon.ink/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Refactoring" scheme="https://tallon.ink/tags/Refactoring/"/>
    
  </entry>
  
  <entry>
    <title>多线程与锁</title>
    <link href="https://tallon.ink/archives/368c49b5.html"/>
    <id>https://tallon.ink/archives/368c49b5.html</id>
    <published>2019-12-01T09:48:50.000Z</published>
    <updated>2020-04-17T11:33:44.609Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>整理 Java 多线程知识，用于日后随时翻阅复习</p>          </div><a id="more"></a><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><img src="http://img3.itboth.com/94/14/F7Bz2a.png" alt="并发包"></p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ol><li>继承 Thread 类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyThread run()"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li><li>实现 Runnable 接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyThread run()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p>实现 Callable 接口通过 FutureTask 包装器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">30</span> ;i++ ) &#123;</span><br><span class="line">System.out.println(<span class="string">"MyThread run()"</span>);</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(thread);</span><br><span class="line"><span class="keyword">new</span> Thread(result).start();</span><br></pre></td></tr></table></figure></li><li><p>使用 ExecutorService、Callable、Future 实现有返回结果的多线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个线程池</span></span><br><span class="line">ExecutorService pool = Exectors.newFixedThreadPool(taskSize);</span><br><span class="line"><span class="comment">// 创建多个又返回值的任务</span></span><br><span class="line">List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; taskSize; i++) &#123;</span><br><span class="line">Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">""</span>);</span><br><span class="line"><span class="comment">// 执行任务并获取Future对象</span></span><br><span class="line">Future f = pool.submit(c);</span><br><span class="line">list.add(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line"><span class="keyword">for</span>(Future f:list)&#123;</span><br><span class="line">System.out.println(<span class="string">"res:"</span>+f.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>sleep():线程睡眠，不会释放当前占有的锁</li><li>wait():线程等待，会释放对象的锁，一般用在同步方法或同步代码块中</li><li>notify():线程唤醒，唤醒在此对象监视器上等待的单个线程（随机）</li><li>notifyAll():线程唤醒，唤醒在此对象监视器上等待的所有线程</li><li>join():当前线程转为阻塞状态，等待其他线程终止，一般用在主线程需要在子线程结束后再结束</li><li>yield():线程让步，让出CPU执行时间片</li><li>interrupt():线程中断，会影响线程内部一个中断标示，不会改变线程状态</li><li>setPriority():设置一个线程的优先级</li><li>getPriority():获得一个线程的优先级</li></ul><h4 id="notify-和-notifyAll-的区别"><a href="#notify-和-notifyAll-的区别" class="headerlink" title="notify() 和 notifyAll() 的区别"></a>notify() 和 notifyAll() 的区别</h4><ol><li>如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的 notifyAll() 方法（唤醒所有 wait 线程）或 notify() 方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait() 方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ol><h4 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep() 和 wait() 的区别"></a>sleep() 和 wait() 的区别</h4><ol><li>sleep() 方法属于 Thread 类中，wait() 方法属于 Object 类</li><li>sleep() 方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。</li><li>在调用 sleep() 方法的过程中，线程不会释放对象锁。<br>当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify() 方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</li></ol><h4 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start() 和 run() 的区别"></a>start() 和 run() 的区别</h4><ol><li>start() 方法启动的线程，真正实现了多线程运行。无需等待 run 方法体执行完毕就可以执行下面的代码</li><li>通过 Thread 类的 start() 方法启动的线程处于<strong>就绪状态</strong>，并没有运行</li><li>run() 称为线程体，它包含了要执行线程的内容，run()执行结束后线程终止，CPU 才会调度其他线程</li></ol><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>线程复用、控制最大并发数、管理线程</strong></p><p><img src="http://img4.imgtn.bdimg.com/it/u=515828614,4275114995&amp;fm=214&amp;gp=0.jpg" alt="线程池"></p><p>Java 里面线程池的顶级接口是 <strong>Executor</strong> ，但严格意义上讲它不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 <strong>ExecutorService</strong>。</p><h4 id="使用线程池的优点"><a href="#使用线程池的优点" class="headerlink" title="使用线程池的优点"></a>使用线程池的优点</h4><ol><li>减少在创建和销毁线程上所花的时间及系统方面的开销</li><li>如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存</li></ol><h4 id="四种常见线程池"><a href="#四种常见线程池" class="headerlink" title="四种常见线程池"></a>四种常见线程池</h4><ol><li>newCachedThreadPool<br> 将首次创建的线程放入缓存，以便之后再来的任务使用<br> 对于执行较多的短期异步任务可大幅提高系统性能<br> 60秒未被使用的线程将被移除，因此长时间空闲不会占用资源</li><li>newFixedThreadPool<br> 创建一个可重用的固定线程数的线程池，以共享的无界队列方式来运行线程</li><li>newScheduledThreadPool<br> 线程池可以安排在给定延迟后运行任务或者定期执行</li><li>newSingleThreadExecutor<br> 线程池中永远只有一个线程，它可以在线程死后（或发生异常）重新启动一个线程来替代原来的线程继续执行下去</li></ol><h3 id="线程生命中期"><a href="#线程生命中期" class="headerlink" title="线程生命中期"></a>线程生命中期</h3><p><img src="http://img4.imgtn.bdimg.com/it/u=3031642779,5963365&amp;fm=26&amp;gp=0.jpg" alt="生命周期"></p><h3 id="停止线程的方式"><a href="#停止线程的方式" class="headerlink" title="停止线程的方式"></a>停止线程的方式</h3><ol><li>使用退出标志(通常由 volatile 修饰，同一时刻只有一个线程修改)</li><li>使用 stop 方法强行终止（过期）</li><li>使用 interrupt 方法中断线程</li></ol><h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。<br>Daemon 的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。</p><h3 id="多线程之间的通讯和协作"><a href="#多线程之间的通讯和协作" class="headerlink" title="多线程之间的通讯和协作"></a>多线程之间的通讯和协作</h3><ol><li>同步（synchronized）</li><li>while 轮询</li><li>wait/notify 机制</li><li>管道通信</li></ol><blockquote><p>分布式系统中说的两种通信机制：共享内存机制和消息通信机制。1 中的 synchronized 关键字和 2 中的 while 轮询 “属于” 共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流。<br>而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。</p></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>ReentrantLock：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p><h3 id="Synchronized-和-java-util-concurrent-locks-Lock的异同"><a href="#Synchronized-和-java-util-concurrent-locks-Lock的异同" class="headerlink" title="Synchronized 和 java.util.concurrent.locks.Lock的异同"></a>Synchronized 和 java.util.concurrent.locks.Lock的异同</h3><p>相同点：Lock 能完成 Synchronized 所实现的所有功能。<br>不同点：Lock 有比 Synchronized 更精确的线程予以和更好的性能。Synchronized 会自动释放锁，但是 Lock 一定要求手工释放，并且必须在 finally 从句中释放。</p><h3 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h3><p>乐观锁是假设每次操作都不会冲突，若是遇到冲突失败就重试直到成功；悲观锁是让其他线程都等待，等锁释放完了再竞争锁。<br>乐观锁实现方式：cas，volatile<br>悲观锁实现方式：synchronized，Lock</p><h2 id="并发框架"><a href="#并发框架" class="headerlink" title="并发框架"></a>并发框架</h2><h3 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h3><p>SynchronizedMap 和 Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。而 ConcurrentHashMap 的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问 ConcurrentHashMap 某个桶时，其他线程，仍然可以对map执行某些操作。<br>所以，ConcurrentHashMap 在性能以及安全性方面，明显比 Collections.synchronizedMap() 更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也不会抛出 ConcurrentModificationException。</p><h3 id="CopyOnWriteArrayList-可以用于什么应用场景？"><a href="#CopyOnWriteArrayList-可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList 可以用于什么应用场景？"></a>CopyOnWriteArrayList 可以用于什么应用场景？</h3><p>CopyOnWriteArrayList 的特性是针对读操作，不做处理，和普通的 ArrayList 性能一样。而在写操作时，会先拷贝一份，实现新旧版本的分离，然后在拷贝的版本上进行修改操作，修改完后，将其更新至就版本中。<br>那么他的使用场景就是：一个需要在多线程中操作，并且频繁遍历。其解决了由于长时间锁定整个数组导致的性能问题，解决方案即写时拷贝。<br>另外需要注意的是 CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite容器。</p><h3 id="Exectors-线程池"><a href="#Exectors-线程池" class="headerlink" title="Exectors 线程池"></a>Exectors 线程池</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>corePoolSize - 池中所保存的线程数，包括空闲线程。</li><li>maximumPoolSize - 池中允许的最大线程数。</li><li>keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</li><li>unit - keepAliveTime 参数的时间单位。</li><li>workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。用BlocingQueue的实现类都可以。</li><li>threadFactory - 执行程序创建新线程时使用的工厂。自定义线程工厂可以做一些额外的操作，比如统计生产的线程数等。</li><li>handler - 饱和策略，即超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。策略有：Abort终止并抛出异常，Discard悄悄抛弃任务，Discard-Oldest抛弃最老的任务策略，Caller-Runs将任务退回给调用者策略。</li></ul><h4 id="线程池设置经验："><a href="#线程池设置经验：" class="headerlink" title="线程池设置经验："></a>线程池设置经验：</h4><ul><li>如果是CPU密集型应用，则线程池大小设置为 N+1</li><li>如果是IO密集型应用，则线程池大小设置为 2N+1</li></ul><h4 id="有界队列、无界队列"><a href="#有界队列、无界队列" class="headerlink" title="有界队列、无界队列"></a>有界队列、无界队列</h4><ol><li>有界队列有助于避免资源耗尽的情况发生。但他带来了新的问题：当队列填满后，新的任务怎么办？所以有界队列适用于执行比较耗资源的任务，同时要设计好相应的饱和策略。</li><li>无界队列和有界队列刚好相反，在资源无限的情况下可以一直接收新任务。适用于小任务，请求和处理速度相对持平的状况。</li><li>其实还有一种同步移交的队列 SynchronousQueue，这种队列不存储任务信息，直接将任务提交给线程池。可以理解为容量只有1的有界队列，在特殊场景下有特殊作用，同样得设计好相应的饱和策略。</li></ol><h3 id="线程计数器"><a href="#线程计数器" class="headerlink" title="线程计数器"></a>线程计数器</h3><p>TODO</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线程安全就是说多线程访问同一代码，不会产生不确定的结果。<br>在多线程环境中，当各线程不共享数据的时候，即都是私有（private）成员，那么一定是线程安全的。但这种情况并不多见，在多数情况下需要共享数据，这时就需要进行适当的同步控制了。<br>线程安全一般都涉及到synchronized，就是一段代码同时只能有一个线程来操作 不然中间过程可能会产生不可预制的结果。<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p><strong><a href="https://mp.weixin.qq.com/s/8GyPdDocRI0NXbiFKAAWrA" target="_blank" rel="noopener">Servlet不是线程安全的</a></strong></p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>synchronized<br> 由该关键字修饰的方法需在调用前获得内置锁</li><li>volatile<ul><li>volatile 关键字为域变量的访问提供了一种免锁机制，</li><li>使用 volatile 修饰域相当于告诉虚拟机该域可能会被其他线程更新</li><li>因此每次使用该域就要重新计算，而不是使用寄存器中的值</li><li>volatile 不会提供任何原子操作，它也不能用来修饰final类型的变量</li></ul></li><li>可重入锁<br> 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock 类是可重入、互斥、实现了Lock接口的锁，它与使用 synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力</li><li>使用局部变量</li></ol><h4 id="volatile-补充说明"><a href="#volatile-补充说明" class="headerlink" title="volatile 补充说明"></a>volatile 补充说明</h4><p>作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值，即不是从寄存器里取备份值，而是去该地址内存存储的值。<br>对变量的写操作不依赖于当前值且该变量没有包含在具有其他变量的不变式中。</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p><img src="https://mrtallon.gitee.io/img/thread01.jpeg" alt="thread01"><br>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。<br>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。<br>它解决了 CPU 多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><h3 id="内存模型解决并发问题主要采用两种方式"><a href="#内存模型解决并发问题主要采用两种方式" class="headerlink" title="内存模型解决并发问题主要采用两种方式"></a>内存模型解决并发问题主要采用两种方式</h3><ol><li>限制处理器优化</li><li>使用内存屏障</li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="两线程交替执行（线程间通信）"><a href="#两线程交替执行（线程间通信）" class="headerlink" title="两线程交替执行（线程间通信）"></a>两线程交替执行（线程间通信）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用阻塞队列实现一个生产者和消费者模型"><a href="#使用阻塞队列实现一个生产者和消费者模型" class="headerlink" title="使用阻塞队列实现一个生产者和消费者模型"></a>使用阻塞队列实现一个生产者和消费者模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现一个流控程序，用于控制请求的调用次数"><a href="#实现一个流控程序，用于控制请求的调用次数" class="headerlink" title="实现一个流控程序，用于控制请求的调用次数"></a>实现一个流控程序，用于控制请求的调用次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;整理 Java 多线程知识，用于日后随时翻阅复习&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="后台" scheme="https://tallon.ink/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="Java" scheme="https://tallon.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Maven 笔记</title>
    <link href="https://tallon.ink/archives/739c0f05.html"/>
    <id>https://tallon.ink/archives/739c0f05.html</id>
    <published>2019-11-30T17:31:50.000Z</published>
    <updated>2020-07-01T08:54:58.050Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>Maven 作为一种强大的项目管理工具，实在不敢说掌握了它的所有知识。<br>以遇到问题的为目录，记录自己对于 Maven 的理解。</p>          </div><a id="more"></a><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=659920890,2281008162&amp;fm=26&amp;gp=0.jpg" alt="maven"></p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>周末在做 Nexus 私服仓库练习（电商）时，遇到了以下疑问：<br>基础域依赖spring全家桶，<br>仓储域依赖spring全家桶，<br>仓储域又依赖基础域，<br>那仓储域是不是就算有两套 spring 的 jar包？<br>虽然用到了 dependencyManagement 来统一管理了一份jar包<br>但是代码确实走了两遍依赖过程吗？<br>那会出现套娃的情况吗？</p><p>因此，学习了 maven 的依赖机制.</p><h2 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h2><p>上述所列出的问题，叫做传递性依赖，它对于嵌套深度没有任何限制，只是出现循环依赖时会报错。<br>因此，导致依赖图增长非常大。为解决这一问题，maven传递依赖提供了以下机制</p><ul><li>依赖调解<ul><li>第一声明优先原则，靠上的依赖包优先进入项目中</li><li>路径近者优先原则</li></ul></li><li>依赖管理<ul><li><dependencyManagement> 标签使用</li></ul></li><li>依赖范围<ul><li>指定只在当前编译范围内包含合适的依赖</li></ul></li><li>排除依赖<ul><li>如果项目X 依赖于项目Y，项目Y 又依赖项目Z，项目X 的所有者可以使用 <strong>exclusion</strong> 元素来显式排除项目Z</li></ul></li><li>可选依赖<ul><li>如果项目Y 依赖项目Z，项目Y 的所有者可以使用 <strong>optional</strong> 元素来指定项目Z 作为X 的可选依赖。那么当项目X 依赖项目Y 时，X 只依赖 Y 并不依赖 Y 的可选依赖 Z。项目X 的所有者也可以根据自己的意愿显式指定 X 对 Z 的依赖。（可以把可选依赖理解为默认排除）</li></ul></li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖范围会影响传递性依赖，同时也会影响项目构建任务中使用的 classpath。<br>Maven有以下6种依赖范围：</p><ul><li><p>compile: 编译依赖范围<br>  如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种 classpath 都有效</p></li><li><p>system: 系统依赖范围<br>  该依赖与编译、测试、运行三种 classpath 的关系，和 provided 依赖范围完全一致。但是，使用system范围依赖时必须通过 systemPath 元素显式地指定依赖文件的路径。由于此类依赖不是通过 Maven 仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。</p></li><li><p>provided: 已提供依赖范围<br>  使用此依赖范围的 Maven 依赖，对于编译和测试 classpath 有效，但在运行时无效。典型的例子是 servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要 Maven 重复地引入一遍</p></li><li><p>runtime: 运行时依赖范围<br>  使用此依赖范围的 Maven 依赖，对于测试和运行 classpath 有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要 JDK 提供的 JDBC 接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体 JDBC驱动</p></li><li><p>test: 测试依赖范围。<br>  使用此依赖范围的 Maven 依赖，只对于测试 classpath 有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子就是JUnit<br>，它只有在编译测试代码及运行测试的时候才需要。</p></li><li><p>import：导入依赖范围<br>  使用此依赖范围不会对三种 classpath 产生影响，该依赖范围只能与 dependencyManagement 元素配合使用，其功能为将目标 pom 文件中 dependencyManagement的 配置导入合并到当前 pom 的 dependencyManagement 中。我认为此功能约等于实现了 Maven 的多继承</p></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>清理生命周期：在进行真正的构建之前进行一些清理工作<ol><li>pre-clean 执行一些需要在clean之前完成的工作</li><li>clean 移除所有上一次构建生成的文件</li><li>post-clean 执行一些需要在clean之后立刻完成的工作</li></ol></li><li>默认生命周期：构建的核心部分，编译，测试，打包，部署等</li><li>站点生命周期：生成项目报告，站点，发布站点，站点的文档<ol><li>pre-site 执行一些需要在生成站点文档之前完成的工作</li><li>site 生成项目的站点文档</li><li>post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy 将生成的站点文档部署到特定的服务器上</li></ol></li></ul><h2 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h2><p><strong>常用命令</strong></p><ul><li>clean 对于构建信息清理</li><li>compile 编译正式代码</li><li>test 编译测试代码</li><li>package 将包打在 target 目录下<br>  clean、resources、compile、testResources、testCompile、test、jar(打包)</li><li>install 安装到本地仓库<br>  clean、resources、compile、testResources、testCompile、test、jar(打包)、install</li><li>deploy 将本地做好的 jar 包上传私服<br>  clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy</li></ul><blockquote><p>一般构建过程中都会手动忽略测试</p></blockquote><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>推荐一些好玩的插件</p><ul><li>scm</li><li>spring-format</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>Maven安装好之后最好不要再换路径了因为即使你重新配置环境变量，也会遇到新的settings文件不生效的问题。还有就是文件的生成路径不在m2下，也不在你指定的路径下。总之会遇到奇奇怪怪的问题，需谨慎</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;Maven 作为一种强大的项目管理工具，实在不敢说掌握了它的所有知识。&lt;br&gt;以遇到问题的为目录，记录自己对于 Maven 的理解。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="后台" scheme="https://tallon.ink/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="Java" scheme="https://tallon.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>工作流</title>
    <link href="https://tallon.ink/archives/637e7d09.html"/>
    <id>https://tallon.ink/archives/637e7d09.html</id>
    <published>2019-11-15T02:34:27.000Z</published>
    <updated>2020-07-17T08:21:14.212Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用增加了难度。<br>分析最常用的几种 Git 工作流让大家可以上手使用。</p>          </div><a id="more"></a><blockquote><p>工作流（Workflow），指“业务过程的部分或整体在计算机应用环境下的自动化”。是对工作流程及其各操作步骤之间业务规则的抽象、概括描述。在计算机中，工作流属于计算机支持的协同工作（CSCW）的一部分。后者是普遍地研究一个群体如何在计算机的帮助下实现协同工作的。<br>工作流主要解决的主要问题是：为了实现某个业务目标，利用计算机在多个参与者之间按某种预定规则自动传递文档、信息或者任务。<br>——《百度百科》</p></blockquote><p><strong>所有工作流是作为方案指导而不是条例规定</strong></p><h2 id="中央集中式"><a href="#中央集中式" class="headerlink" title="中央集中式"></a>中央集中式</h2><p>所有人向一个公共仓库扔代码，较原始，不利于版本迭代。</p><p><img src="https://mrtallon.gitee.io/img/git003.png" alt="git003"></p><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h2><p>通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。<br>严格的分支模型也为大型项目提供了一些非常必要的结构。<br>在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。</p><p><img src="https://mrtallon.gitee.io/img/git006.png" alt="git006"></p><h3 id="历史分支"><a href="#历史分支" class="headerlink" title="历史分支"></a>历史分支</h3><p>相对使用仅有的一个 master 分支，GitFlow 工作流使用2个分支来记录项目的历史。master 分支存储了正式发布的历史，而 develop 分支作为功能的集成分支。这样也方便 master 分支上的所有提交分配一个版本号。</p><p><img src="https://mrtallon.gitee.io/img/git007.png" alt="git007"></p><h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>每个新功能位于一个自己的分支，这样可以 push 到中央仓库以备份和协作。但功能分支不是从 master 分支上拉出新分支，而是使用 develop 分支作为父分支。当新功能完成时，合并回 develop 分支。新功能提交应该从不直接与 master 分支交互。</p><p><img src="https://mrtallon.gitee.io/img/git008.png" alt="git008"></p><h3 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h3><p><img src="https://mrtallon.gitee.io/img/git009.png" alt="git009"></p><h3 id="维护分支"><a href="#维护分支" class="headerlink" title="维护分支"></a>维护分支</h3><p><img src="https://mrtallon.gitee.io/img/git010.png" alt="git010"></p><h3 id="版本号说明"><a href="#版本号说明" class="headerlink" title="版本号说明"></a>版本号说明</h3><p>v1.0.0-&gt;v1.0.1：    热修复<br>v1.0.0-&gt;v1.1.0：    新增功能</p><h3 id="演示事例"><a href="#演示事例" class="headerlink" title="演示事例"></a>演示事例</h3><p><strong>小红</strong><br>基于 master 拉取项目<br>创建 develop 开发分支<br>切换开发分支并推送远程（模块组长）<br>新建文件并上传 develop 分支</p><blockquote><p>你的开发项目应该是在 feature+模块名的分支，如果人少，实在没必要了，我直接默认每个人都在 develop 开发</p></blockquote><p><strong>小明</strong><br>拉取 master，切换 develop，查看新文件，并新增功能然后上传</p><p>开发的一定阶段，合并 master<br>做法就是再开发一个分支，基于 dep，命名 release-1.0.0<br>切换 release，测试走一遍，无任何 bug 再推送 master<br>只有预发售版才能合并 master。</p><p>本地回到 master 分支，拉取完整项目，创建标签，<br>1.0.0-RELEASE，推送仓库（包括标签）<br>查看一下标签，完美。</p><p><strong>问题</strong>：1.0.0 的 bug 出来了</p><p>解决：<br>new issue 提bug<br>使用 hotfix（补丁分支）来修复<br>通过标签检出，会发现自动创建新分支，<br>因为<strong>标签就是不可再修改了</strong></p><p>新分支：hotfix_0004（序号）<br>新建文件表示修复（提交到 hotfix 分支）<br>之后 hotfix 直接合并到 master。<br>最后切换分支到 master 拉取最新，<br>发现 master 分支已修复，</p><p>发布新版本，创建标签，<br>1.0.1-RELEASE<br>推送到服务器（包括标签）<br>最后，删除 dep 和 master 的其余分支</p><h3 id="Forking"><a href="#Forking" class="headerlink" title="Forking"></a>Forking</h3><p>特大型项目会用到，暂时不写了</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到了这里，但愿你对集中式工作流、功能分支工作流和 GitFlow 工作流已经感觉很舒适了。应该牢固的掌握了本地仓库的潜能，push/pull 模式和 Git 健壮的分支和合并模型。</p><p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用 Git 不可违逆的条例。所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让 Git 为你所用。</p><p><img src="https://mrtallon.gitee.io/img/git005.png" alt="git005"></p><h2 id="个人-Tips"><a href="#个人-Tips" class="headerlink" title="个人 Tips"></a>个人 Tips</h2><p>在写提交日志时，也许只是多加一个<a href="https://gitmoji.carloscuesta.me/" target="_blank" rel="noopener">emoji</a>，就能表达很多（前提是大家统一符合规范）</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用增加了难度。&lt;br&gt;分析最常用的几种 Git 工作流让大家可以上手使用。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="后台" scheme="https://tallon.ink/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="工作流" scheme="https://tallon.ink/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>oAuth2 认证</title>
    <link href="https://tallon.ink/archives/f1d083c7.html"/>
    <id>https://tallon.ink/archives/f1d083c7.html</id>
    <published>2019-09-02T15:25:13.000Z</published>
    <updated>2020-11-23T15:09:53.320Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>原文是关于 SSO 的单点登录总结，现更改为 oAuth2 协议技术</p>          </div><a id="more"></a><h2 id="oAuth"><a href="#oAuth" class="headerlink" title="oAuth"></a>oAuth</h2><p>oAuth 协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 oAuth 的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此 oAuth 是安全的。</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>Spring Security 是一个安全框架，前身是 Acegi Security，能够为 Spring 企业应用系统提供声明式的安全访问控制。Spring Security 基于 Servlet 过滤器、IoC 和 AOP，为 Web 请求和方法调用提供身份确认和授权处理，避免了代码耦合，减少了大量重复代码工作。</p><p>Spring Security 是 SpringCloud 官方支持的安全管理工具包。<br>与 Shiro 相比，功能更加丰富，例如安全防护，对于 oAuth2 的支持也更加方便。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>单点登录</li><li>第三方开放平台<ul><li>授权码模式保护密码</li><li>scope增加权限范围</li><li>动态调整权限使用时间</li></ul></li></ul><h2 id="认证系统组件"><a href="#认证系统组件" class="headerlink" title="认证系统组件"></a>认证系统组件</h2><ul><li><strong>第三方应用程序</strong>（Third-party application）： 又称之为客户端（client），比如PC、Android、iPhone、TV、Watch，我们会在这些设备中安装我们自己研发的 APP。又比如我们的产品想要使用 QQ、微信等第三方登录。对我们的产品来说，QQ、微信登录是第三方登录系统。我们又需要第三方登录系统的资源（头像、昵称等）。对于 QQ、微信等系统我们又是第三方应用程序。</li><li><strong>HTTP 服务提供商</strong>（HTTP service）： 云笔记产品以及 QQ、微信等都可以称之为“服务提供商”。</li><li><strong>资源所有者</strong>（Resource Owner）： 又称之为用户（user）。</li><li><strong>用户代理</strong>（User Agent）： 比如浏览器，代替用户去访问这些资源。</li><li><strong>认证服务器</strong>（Authorization server）： 即服务提供商专门用来处理认证的服务器，简单点说就是登录功能（验证用户的账号密码是否正确以及分配相应的权限）</li><li><strong>资源服务器</strong>（Resource server）： 即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。简单点说就是资源的访问入口，比如上节中提到的“云笔记服务”和“云相册服务”都可以称之为资源服务器。</li></ul><h2 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h2><p>oAuth 在 “客户端” 与 “服务提供商” 之间，设置了一个授权层（authorization layer）。”客户端” 不能直接登录 “服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端” 登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。”客户端” 登录授权层以后，”服务提供商” 根据令牌的权限范围和有效期，向 “客户端” 开放用户储存的资料。<br><img src="https://mrtallon.gitee.io/img/oauth1.jpg" alt="交互图"></p><h2 id="开放平台"><a href="#开放平台" class="headerlink" title="开放平台"></a>开放平台</h2><p>对于初次接触的同学来说，“开放平台”可能是一个不太好理解的概念。<br>这是由 oAuth2.0 协议衍生出来的一个产品。它的作用是让客户端自己去这上面进行注册、申请，<br>通过之后系统自动分配 <code>client_id</code> ，并完成配置的自动更新（通常是写进数据库）。</p><p>客户端要完成申请，通常需要填写客户端程序的类型（Web、App 等）、企业介绍、执照、想要获取的权限等等信息。这些信息在得到服务提供方的人工审核通过后，开发平台就会自动分配一个 <code>client_id</code> 给客户端了。</p><p>有对接过支付宝、微信、网易等第三方接口，就一定会用到开放平台。</p><h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><p>oAuth2 官方提供以下四种授权模式</p><h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p>适用于没有自己服务器、没有持久化存储能力的的纯静态页面，因此无法做到真正的安全</p><p><img src="https://mrtallon.gitee.io/img/oauth2.png" alt="oauth2"></p><p>用户名密码直接明文保存在配置文件中，用户登录信息会以密文保存在链接请求头中，通过Base64解密即可识破</p><h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p>拥有独立服务器的应用，用户获得的仅是一个临时凭证</p><p><img src="https://mrtallon.gitee.io/img/oauth3.png" alt="oauth3"></p><p>code的存在，大大提升了token的安全性。因为即使code被盗取，也无法在没有secret的前提下换取token</p><p>这是官方推荐授权方式（主要用于第三方开放平台）</p><h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>拥有独立服务器的应用，用户获得的仅是一个临时凭证</p><p><img src="https://mrtallon.gitee.io/img/oauth4.png" alt="oauth4"></p><p>此模式用于同一公司下的不同产品线，处于不同生产环境而又彼此信任<br>不需要向用户展示“xxx将获取以下权限”等字样并询问用户的授权意向，而只需进行用户的身份认证即可</p><h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>拥有独立服务器的应用，用户获得的仅是一个临时凭证</p><p><img src="https://mrtallon.gitee.io/img/oauth5.png" alt="oauth5"></p><p>调用者仅是一个后端的模块，没有用户界面<br>鉴权服务器直接对客户端进行身份验证，验证通过后，返回 token</p><h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><p><img src="https://mrtallon.gitee.io/img/oauth6.png" alt="oauth6"></p><h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p>RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。</p><p><img src="https://mrtallon.gitee.io/img/oauth7.png" alt="oauth7"></p><p>通过以上五张表实现用户与权限的对应关系，如下示例</p><p><img src="https://mrtallon.gitee.io/img/oauth8.png" alt="oauth8"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>具体代码详情参考<a href="https://github.com/MrTallon/easy/tree/master/oauth" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;原文是关于 SSO 的单点登录总结，现更改为 oAuth2 协议技术&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="认证" scheme="https://tallon.ink/categories/%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="Security" scheme="https://tallon.ink/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>云原生</title>
    <link href="https://tallon.ink/archives/701331c8.html"/>
    <id>https://tallon.ink/archives/701331c8.html</id>
    <published>2019-08-15T18:40:18.000Z</published>
    <updated>2020-07-17T07:36:46.804Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>投入公司新开的云原生项目三月有余，如今对于云原生的理解依旧不甚了了，<br>翻出 O`REILLY 的《云原生Java》，系统学习。</p>          </div><a id="more"></a><p><img src="https://mrtallon.gitee.io/img/cloudNative1.jpeg" alt="cloudNative"></p><blockquote><p>即使到现在，云原生尚且没有确切的定义，一直处于变化之中，解释权不归某个人或组织所有。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>云原生是一种构建和运行应用程序的方法，是一套技术体系和方法论。</strong><br>云原生是一个组合词，<strong>Cloud</strong> + <strong>Native</strong>。<br>Cloud 表示应用程序位于云中，而不是传统的数据中心；<br>Native 表示应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳姿势运行，充分利用和发挥云平台的弹性 + 分布式优势。</p><p>2013年首次提出云原生的概念；<br>2015年 Matt Stine 在《迁移到云原生架构》一书中定义了符合云原生架构的几个特征：</p><ul><li>十二要素</li><li>微服务</li><li>自敏捷架构</li><li>基于 API 协作、扛脆弱性；</li></ul><p>到了2017年，Matt Stine 改了口风，将云原生架构归纳为<strong>模块化</strong>、<strong>可观察</strong>、<strong>可部署</strong>、<strong>可测试</strong>、<strong>可替换</strong>、<strong>可处理</strong>六特质；<br>而 Pivotal 最新官网对云原生概括为四个要点：<strong>DevOps</strong> + <strong>持续交付</strong> + <strong>微服务</strong> + <strong>容器</strong>。</p><p><img src="https://mrtallon.gitee.io/img/cloudNative2.jpg" alt="cloudstructs"></p><p>总而言之，符合云原生架构的应用程序应该是：<br>采用开源堆栈(K8S + Docker) 进行容器化，<br>基于微服务架构提高灵活性和可维护性，<br>借助敏捷方法、DevOps支持持续迭代和运维自动化，<br>利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。</p><p>云原生构建应用简便快捷，部署应用轻松自如、运行应用按需伸缩。<br>优点不一而足，缺点微乎其微，秒杀传统 Web 框架，吊打祖传 IT 模式，<br>实在是保命或评优晋级的不可多得的终极绝密武器。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务理论基础：<a href="https://yq.aliyun.com/articles/8611" target="_blank" rel="noopener">康威定律</a></p><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p><strong>定义：开发、运维和测试的合体</strong><br>DevOps 是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。</p><h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h3><p>敏捷开发，小步快跑，快速迭代，持续交付<br><img src="https://mrtallon.gitee.io/img/cloudNative4.jpg" alt="cloudci"></p><h3 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h3><p>Docker 是应用最为广泛的容器引擎(目前创始人已经离开团队)<br>K8S 是容器编排系统，用于容器管理，容器间的负载均衡<br><img src="https://mrtallon.gitee.io/img/cloudNative3.jpg" alt="cloudk8s"></p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>云原生借了云计算的东风，没有云计算，自然没有云原生，云计算是云原生的基础。<br>随着虚拟化技术的成熟和分布式框架的普及，在容器技术、可持续交付、编排系统等开源社区的推动下，以及微服务等开发理念的带动下，应用上云已经是不可逆转的趋势。<br>云计算的3层划分，即基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS) 为云原生提供了技术基础和方向指引，真正的云化不仅仅是基础设施和平台的变化，应用也需要做出改变，摈弃传统的土方法，在架构设计、开发方式、部署维护等各个阶段和方面都基于云的特点，重新设计，从而建设全新的云化的应用，即云原生应用。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h3><h3 id="Privotal"><a href="#Privotal" class="headerlink" title="Privotal"></a>Privotal</h3><p>是什么？为什么？怎么用？</p><p>快速开始就不展开介绍了，<a href="https://run.pivotal.io/" target="_blank" rel="noopener">官网</a>有详细的教程步骤。</p><blockquote><p>MacOS 克隆下项目记得给文件夹赋权。</p></blockquote><p><img src="https://mrtallon.gitee.io/img/cloudNative5.png" alt="cloudNative5"></p><p><strong>SpringBoot 云上优化之路</strong><br>本机运行运行项目从未考虑过 SpringBoot 需要优化，一是本地资源较少，即使启动了 cloud 项目，在 32G 内存的 MacBook Pro 面前也是不足为惧，二是过早优化往往是烦恼的开端。<br>但是当项目布置云上环境时，哪怕是为了 10M 的内存也需要优化改造，珍惜每一寸空间。</p><p>对比优化前后启动状态⚠️</p><ol><li>减小 JVM 启动堆内存分配空间，Xms设置为了64M</li><li>按需修改 Tomcat 启动线程数<br>Tomcat 默认线程是200，个人项目没有这么高的并发量，故修改为10。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">      <span class="attr">max-threads:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>优化建议</strong></p><ul><li><a href="https://blog.csdn.net/wy674396380/article/details/80527530" target="_blank" rel="noopener">内存压榨</a></li><li><a href="https://blog.csdn.net/qq_35623773/article/details/100529598" target="_blank" rel="noopener">减少启动内存</a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试是持续交付的一个重要方面。</p><p>在持续交付中，软件构件会通过一个管道向后移动，最终产生可用于生产环境的构件。<br>随着软件在持续交付管道中不断前进，测试会变的越来越复杂和缓慢。<br>理想情况下，单元测试和集成测试应该在非常短的时间内完成80%～90%的用例，从而确保此条件下的代码（可能）可以被推向生产环境。<br>Spring Cloud 通过消费者驱动契约测试(CDC-T) 进一步扩展了原有的测试能力。<br>在云原生系统中，一切都是自动，包括部署。这是有效完成冒烟测试和获得一致性的关键因素。</p><blockquote><p>消费者驱动的契约测试(CDC-T) 是利用已发布的契约来断言和维护消费者和生产者之间的期望，同时保证服务之间的松耦合性。<br>它的核心前提是允许微服务架构中生产者和消费者以（消费者驱动）契约的形式发布（并建立）存根。</p></blockquote><p>Spring Cloud Contract 是 Spring 家族中一个开源项目，它通过一种消费驱动契约的变体来提供框架组件。消费者驱动契约通常用于集成测试分布式的应用程序组件，例如 REST API 和为服务之间的消息变换。Spring Cloud Contract 支持使用存根发布和模拟远程服务的能力。</p><h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2><blockquote><p>参考文献：<br><a href="https://mp.weixin.qq.com/s/7-jf3cv0j164igzZDx15Jw" target="_blank" rel="noopener">阿里技术：云原生</a><br><a href="">阿里巴巴云原生实践15讲</a><br><a href="http://cloudnativejava.io/" target="_blank" rel="noopener">云原生Java</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;投入公司新开的云原生项目三月有余，如今对于云原生的理解依旧不甚了了，&lt;br&gt;翻出 O`REILLY 的《云原生Java》，系统学习。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="运维" scheme="https://tallon.ink/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Cloud" scheme="https://tallon.ink/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Netty</title>
    <link href="https://tallon.ink/archives/1c6ba3e2.html"/>
    <id>https://tallon.ink/archives/1c6ba3e2.html</id>
    <published>2019-08-05T16:11:36.000Z</published>
    <updated>2019-11-17T11:01:32.736Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>One Framework to rule them all ……</p><div style="text-align: center"> ———— Norman Maurer </div>          </div><a id="more"></a><BGM="笑看风云——汪小敏.mp3" /><p>由于CPU的处理速度远超磁盘速度，因此高效的信息传输必是优化的重点和难点。</p><p>分享一篇学习Netty过程中的技术总结。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Netty is an asynchronous event-driven network application framework<br>for rapid development of maintainable high performance protocol servers &amp; clients.<br>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server.            ——netty.io</p></blockquote><p>Netty 不解决读写硬盘文件的工作，用来解决网络问题。<br>它是JVM上被使用最广泛的编程框架之一，其实很多的编程框架尤其是网络编程框架是建立在Netty之上的。<br>如果不想直接使用JDK提供的NIO接口，大多数人便会使用Netty，或者由Netty封装的框架。<br>由 Trustin Lee（韩国）创建。</p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p><strong>BIO-〉NIO -〉AIO -〉Netty</strong></p><h3 id="BI（Blocking-IO）"><a href="#BI（Blocking-IO）" class="headerlink" title="BI（Blocking IO）"></a>BI（Blocking IO）</h3><p><strong>同步阻塞</strong><br>server会建立一个空缺的接口等客户端连上来，期间属于阻塞状态。<br><strong>阻塞点</strong></p><ul><li>server端的accept，一旦client不连上来，对于服务器当前的线程来说即阻塞</li><li>client连接后建立新线程处理，其中的read和write也是阻塞的</li><li>如果并发稍高的话大部分比较线程处于等待状态</li></ul><h3 id="NIO（Non-Blocking-IO）"><a href="#NIO（Non-Blocking-IO）" class="headerlink" title="NIO（Non-Blocking IO）"></a>NIO（Non-Blocking IO）</h3><p><strong>同步非阻塞</strong><br>加入selector接口，以轮询方式查看server当前状态，帮助client的连接和读写。<br>其中的<strong>byteBuffer</strong>接口很难用，flip 操作让人头疼，严重影响开发。<br>NIO实际开发过程中以reactor模式为主，selector不再处理server与clien的连接和读写，而作为线程池的管理员，让各个线程来操作具体的事情。</p><h3 id="AIO（Asynchronous-IO）"><a href="#AIO（Asynchronous-IO）" class="headerlink" title="AIO（Asynchronous IO）"></a>AIO（Asynchronous IO）</h3><p><strong>异步非阻塞</strong><br>不再需要轮询。当client需要连接时，交给OS去处理，之后再通知selector去处理连接操作。<br>AIO的模型封装比BIO好用很多，并且OS的处理速度也是量级的提升。<br>但是Linux底层中对于AIO和NIO都是由epoll实现的（轮询），导致Netty都是基于NIO的产物，封装的API比较像AIO</p><blockquote><p>注：Windows上的AIO是单独实现的，属于OS的事件模型（速度很快），不过目前世界上的大多数server都是Linux</p></blockquote><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p><strong>异步非阻塞</strong><br>底层基于NIO和BIO封装成了AIO的样子。<br><a href="https://netty.io/" target="_blank" rel="noopener">官网</a>写的已经很详细了</p><p>作用</p><ul><li>RPC通信协议，实现远程调用（基于socket）</li><li>长连接服务器，实现客户端与服务端的长连接通信</li><li>HTTP服务器，类似Tomcat，但不遵循servelt规范</li></ul><p>Netty 3.X</p><ul><li>too much garbage</li><li>too many memory copies</li><li>no good memory pool include</li><li>not optimized for Linux based OS</li><li>threading model not easy to reason about</li></ul><p>虽然问题重重，并且已经停止维护，但是由于能用，如今服役面积仍然广泛。</p><p>Netty 4.X</p><ul><li>creat less garbage,less GC</li><li>opimized for Linux base OS + Linux only features</li><li>high performance buffer pool based on jemalloc paper</li><li>well defined,easy to use threading model</li></ul><p>Netty4 的封装基于JNI，更加优雅的调用底层接口和跨平台服务。<br>想要试用基于Linux的Native传输层，保持代码基本不变的情况下只修改两个类名即可。</p><p><img src="https://mrtallon.gitee.io/img/netty1.jpg" alt="nettyModel"></p><p>Netty中有一个Channel的概念，Channel是对Socket的抽象。<br>当写数据时,数据会走socket，然后调用write系统操作来把数据发送出去。</p><h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><h3 id="通用流程"><a href="#通用流程" class="headerlink" title="通用流程"></a>通用流程</h3><ol><li>定义好父子线程组</li><li>构造启动器</li><li>childHandler中定义Initiallizer</li><li>Initiallizer添加自定义的通道处理器（ServerHandler）</li><li>ServerHandler中处理请求和响应数据</li><li>回调方法被调用</li><li>关流</li></ol><h3 id="架构实现"><a href="#架构实现" class="headerlink" title="架构实现"></a>架构实现</h3><h3 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h3><h3 id="HTTP-Tunnel"><a href="#HTTP-Tunnel" class="headerlink" title="HTTP Tunnel"></a>HTTP Tunnel</h3><h3 id="对Socket的实现"><a href="#对Socket的实现" class="headerlink" title="对Socket的实现"></a>对Socket的实现</h3><h3 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h3><h3 id="对RPC的支援"><a href="#对RPC的支援" class="headerlink" title="对RPC的支援"></a>对RPC的支援</h3><h3 id="NIO模型在Netty中的实现"><a href="#NIO模型在Netty中的实现" class="headerlink" title="NIO模型在Netty中的实现"></a>NIO模型在Netty中的实现</h3><h3 id="编解码开发技术"><a href="#编解码开发技术" class="headerlink" title="编解码开发技术"></a>编解码开发技术</h3><h3 id="重要类与接口源代码剖析"><a href="#重要类与接口源代码剖析" class="headerlink" title="重要类与接口源代码剖析"></a>重要类与接口源代码剖析</h3><h3 id="Channel分析"><a href="#Channel分析" class="headerlink" title="Channel分析"></a>Channel分析</h3><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><h4 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h4><h4 id="连接建立方式与生命周期分解"><a href="#连接建立方式与生命周期分解" class="headerlink" title="连接建立方式与生命周期分解"></a>连接建立方式与生命周期分解</h4><h4 id="服务端与客户端开发"><a href="#服务端与客户端开发" class="headerlink" title="服务端与客户端开发"></a>服务端与客户端开发</h4><h3 id="RPC框架分析"><a href="#RPC框架分析" class="headerlink" title="RPC框架分析"></a>RPC框架分析</h3><h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;One Framework to rule them all ……&lt;/p&gt;&lt;div style=&quot;text-align: center&quot;&gt; ———— Norman Maurer &lt;/div&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://tallon.ink/categories/Netty/"/>
    
    
      <category term="负载均衡" scheme="https://tallon.ink/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式主键解决方案</title>
    <link href="https://tallon.ink/archives/88462ef5.html"/>
    <id>https://tallon.ink/archives/88462ef5.html</id>
    <published>2019-07-17T02:03:02.000Z</published>
    <updated>2020-07-17T08:38:28.187Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>分布式环境中分库分表后主键解决方案</p>          </div><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>为存储项目中订单、商品等模块海量数据，故进行分库分表操作。<br>在此环境下，一款合适的主键生成策略成为问题。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>全局唯一</li><li>趋势递增</li><li>信息安全（不连续，不规则）</li><li>低延迟</li><li>高可用</li><li>高QPS</li></ul><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><div class="table-container"><table><thead><tr><th style="text-align:center">ID策略</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">UUID</td><td style="text-align:center">性能非常高；本地生成，没有网络消耗</td><td style="text-align:center">26位太长；可能泄露MAC地址；MySQL建议数字最好，越短越好</td></tr><tr><td style="text-align:center">数据库自增</td><td style="text-align:center">简单</td><td style="text-align:center">强依赖DB；单台MySQL性能瓶颈；不够安全</td></tr><tr><td style="text-align:center">Snowflake</td><td style="text-align:center">趋势递增；高性能；根据业务灵活分配bit位</td><td style="text-align:center">强依赖机器时钟</td></tr></tbody></table></div><p>为解决以上问题，使用 <a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">Leaf</a></p><blockquote><p>Leaf 是美团开源的分布式 ID 生成系统，最早期需求是各个业务线的订单 ID 生成需求。在美团早期，有的业务直接通过 DB 自增的方式生成 ID，有的业务通过 Redis 缓存来生成 ID，也有的业务直接用 UUID 这种方式来生成 ID。以上的方式各自有各自的问题，因此美团决定实现一套分布式 ID 生成服务来满足需求<br>目前 Leaf 覆盖了美团点评公司内部金融、餐饮、外卖、酒店旅游、猫眼电影等众多业务线。在4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms（TP=Top Percentile，Top 百分数，是一个统计学里的术语，与平均数、中位数都是一类。TP50、TP90 和 TP99 等指标常用于系统性能监控场景，指高于 50%、90%、99% 等百分线的情况）</p></blockquote><p>项目中使用 Leaf-snowflake 方式生成 ID</p><p>Leaf-snowflake 方案完全沿用 snowflake 方案的 bit 位设计，即是「1+41+10+12」 的方式组装 ID 号。对于 workerID 的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf 服务规模较大，动手配置成本太高。所以使用 Zookeeper 持久顺序节点的特性自动对 snowflake 节点配置 wokerID。</p><h3 id="弱依赖-Zookeeper"><a href="#弱依赖-Zookeeper" class="headerlink" title="弱依赖 Zookeeper"></a>弱依赖 Zookeeper</h3><p>除了每次会去 ZK 拿数据以外，也会在本机文件系统上缓存一个 workerID 文件。当 ZooKeeper 出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。这样做到了对三方组件的弱依赖。一定程度上提高了 SLA（Service Level Agreement 服务等级协议，是在一定开销下为保障服务的性能和可用性，网站服务可用性 SLA，9 越多代表全年服务可用时间越长服务更可靠，停机时间越短，反之亦然）</p><h3 id="解决时钟问题"><a href="#解决时钟问题" class="headerlink" title="解决时钟问题"></a>解决时钟问题</h3><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><blockquote><p>为方便实用，将 Leaf 项目进行二次处理，编写 bash 脚本和 docker-compose，实现一次构建，到处运行</p></blockquote><h3 id="启动步骤"><a href="#启动步骤" class="headerlink" title="启动步骤"></a>启动步骤</h3><ul><li>启动 Leaf-snowflake 服务，连接 Zookeeper，在 leaf_forever 父节点下检查自己是否已经注册过（是否有该顺序子节点）</li><li>如果有注册过直接取回自己的 workerID（zk 顺序节点生成的 int 类型 ID 号），启动服务</li><li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的 workerID 号，启动服务</li></ul><ol><li><code>cd clone https://github.com/funtl/Leaf.git</code></li><li><code>cd Leaf</code></li><li><code>mvn clean install -D</code></li><li><code>cd leaf-docker</code></li><li><code>chomd 777 build.sh</code></li><li><code>./build.sh</code></li><li><code>docker-compose up -d</code></li></ol><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><h3 id="zookeeper-高可用集群"><a href="#zookeeper-高可用集群" class="headerlink" title="zookeeper 高可用集群"></a>zookeeper 高可用集群</h3><h3 id="Leaf-高可用"><a href="#Leaf-高可用" class="headerlink" title="Leaf 高可用"></a>Leaf 高可用</h3><p>leaf-server部署成高可用的负载均衡模式</p><h3 id="高速通信"><a href="#高速通信" class="headerlink" title="高速通信"></a>高速通信</h3><p>最初工具类使用的是 OKHttp的方式获取ID，但生产环境下该效率较低<br>为提高速度，优化为 <strong>对内 RPC，对外 REST</strong>的调用方式</p><h3 id="hsah分布"><a href="#hsah分布" class="headerlink" title="hsah分布"></a>hsah分布</h3><p>落入不同库中的数据是否数量大致相等，一个月后待观测</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;分布式环境中分库分表后主键解决方案&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://tallon.ink/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="https://tallon.ink/archives/65b69107.html"/>
    <id>https://tallon.ink/archives/65b69107.html</id>
    <published>2019-04-04T04:57:31.000Z</published>
    <updated>2020-09-18T15:56:37.858Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>Nginx 系统学习和实操应用，并实现伪 CDN 功能。</p>          </div><a id="more"></a><blockquote><p>以 Docker 容器实现 Nginx 服务</p></blockquote><h2 id="Nginx-简介"><a href="#Nginx-简介" class="headerlink" title="Nginx 简介"></a>Nginx 简介</h2><p>Nginx 是一款高性能的 HTTP 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师 Igor Sysoev 所开发，官方测试 Nginx 能够支支撑 5 万并发链接，并且 CPU、内存等资源消耗却非常低，运行非常稳定。</p><h2 id="Nginx-的应用场景"><a href="#Nginx-的应用场景" class="headerlink" title="Nginx 的应用场景"></a>Nginx 的应用场景</h2><ul><li>HTTP 服务器：Nginx 是一个 HTTP 服务可以独立提供 HTTP 服务。可以做网页静态服务器。</li><li>虚拟主机：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</li><li>反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 Nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</li></ul><h2 id="什么是虚拟主机"><a href="#什么是虚拟主机" class="headerlink" title="什么是虚拟主机"></a>什么是虚拟主机</h2><p>虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。</p><p>通过 Nginx 可以实现虚拟主机的配置，Nginx 支持三种类型的虚拟主机配置</p><ul><li>基于 IP 的虚拟主机</li><li>基于域名的虚拟主机</li><li>基于端口的虚拟主机</li></ul><h2 id="Nginx-配置文件的结构"><a href="#Nginx-配置文件的结构" class="headerlink" title="Nginx 配置文件的结构"></a>Nginx 配置文件的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">events &#123;</span><br><span class="line"># ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"># ...</span><br><span class="line">server&#123;</span><br><span class="line"># ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line">server&#123;</span><br><span class="line"># ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每个 server 就是一个虚拟主机</p></blockquote><h2 id="什么是代理服务器"><a href="#什么是代理服务器" class="headerlink" title="什么是代理服务器"></a>什么是代理服务器</h2><p>代理服务器，客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。</p><h2 id="为什么要使用代理服务器"><a href="#为什么要使用代理服务器" class="headerlink" title="为什么要使用代理服务器"></a>为什么要使用代理服务器</h2><h3 id="提高访问速度"><a href="#提高访问速度" class="headerlink" title="提高访问速度"></a>提高访问速度</h3><p>由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门站点能明显提高请求速度。</p><h3 id="防火墙作用"><a href="#防火墙作用" class="headerlink" title="防火墙作用"></a>防火墙作用</h3><p>由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可在代理服务器上设限，过滤某些不安全信息。</p><h3 id="通过代理服务器访问不能访问的目标站点"><a href="#通过代理服务器访问不能访问的目标站点" class="headerlink" title="通过代理服务器访问不能访问的目标站点"></a>通过代理服务器访问不能访问的目标站点</h3><p>互联网上有许多开放的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，虽然不能出国，但也可直接访问外网。</p><h2 id="什么是正向代理"><a href="#什么是正向代理" class="headerlink" title="什么是正向代理"></a>什么是正向代理</h2><p>正向代理，架设在客户机与目标主机之间，只用于代理内部网络对 Internet 的连接请求，客户机必须指定代理服务器,并将本来要直接发送到 Web 服务器上的 Http 请求发送到代理服务器中。</p><h2 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理"></a>什么是反向代理</h2><p>反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。</p><h2 id="反向代理有哪些主要应用"><a href="#反向代理有哪些主要应用" class="headerlink" title="反向代理有哪些主要应用"></a>反向代理有哪些主要应用</h2><p>现在许多大型 web 网站都用到反向代理。除了可以防止外网对内网服务器的恶性攻击、缓存以减少服务器的压力和访问安全控制之外，还可以进行负载均衡，将用户请求分配给多个服务器。</p><h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><p>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p>负载均衡，英文名称为 Load Balance，其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>如何解决跨域问题</p><h2 id="使用-CORS（跨资源共享）解决跨域问题"><a href="#使用-CORS（跨资源共享）解决跨域问题" class="headerlink" title="使用 CORS（跨资源共享）解决跨域问题"></a>使用 CORS（跨资源共享）解决跨域问题</h2><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。</p><p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信（在 header 中设置：Access-Control-Allow-Origin）</p><h2 id="使用-JSONP-解决跨域问题"><a href="#使用-JSONP-解决跨域问题" class="headerlink" title="使用 JSONP 解决跨域问题"></a>使用 JSONP 解决跨域问题</h2><p>JSONP（JSON with Padding）是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与 server2.example.com 的服务器沟通，而 HTML 的 <script> 元素是一个例外。利用 <script> 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析（需要目标服务器配合一个 callback 函数）。</p><h3 id="CORS-与-JSONP-的比较"><a href="#CORS-与-JSONP-的比较" class="headerlink" title="CORS 与 JSONP 的比较"></a>CORS 与 JSONP 的比较</h3><p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。</p><p>JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p><h2 id="使用-Nginx-反向代理解决跨域问题"><a href="#使用-Nginx-反向代理解决跨域问题" class="headerlink" title="使用 Nginx 反向代理解决跨域问题"></a>使用 Nginx 反向代理解决跨域问题</h2><p>以上跨域问题解决方案都需要服务器支持，当服务器无法设置 header 或提供 callback 时我们就可以采用 Nginx 反向代理的方式解决跨域问题。</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;Nginx 系统学习和实操应用，并实现伪 CDN 功能。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>程序往事</title>
    <link href="https://tallon.ink/archives/95c6ffba.html"/>
    <id>https://tallon.ink/archives/95c6ffba.html</id>
    <published>2019-03-09T20:02:38.000Z</published>
    <updated>2020-07-17T07:56:10.032Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>记录那些慢慢过去的，慢慢迎来的，或感怀，或心得，往复更替。<br>预计更新五年。</p>          </div><a id="more"></a><h2 id="第一更：轻装上阵，梦想起航"><a href="#第一更：轻装上阵，梦想起航" class="headerlink" title="第一更：轻装上阵，梦想起航"></a>第一更：轻装上阵，梦想起航</h2><div style="text-align: right"> 2019.03.17 </div><p><img src="https://mrtallon.gitee.io/img/diary4.jpeg" alt="区块链"></p><p>偶然间看到了 Lusifer 课堂视频，获益匪浅，见识了资深程序员的开发思想，并定制自己的学习路线。</p><p>2018年还很少听到企业采用微服务框架，如今的企业开发，微服务已大行其道。</p><p>我认为，当下的 Java 程序员，入门的标准，不再是曾经的 SSM，起码有微服务的编程思想。<br>思考问题要有一定的高度，当拥有降维打击的能力时，那就无坚不摧了。</p><blockquote><p>微服务这个概念是2012年出现的，作为加快 Web 和移动应用程序开发进程的一种方法。<br>2014年开始受到各方的关注，同年为微服务的元年。</p></blockquote><p>2019重点学习计划一：<strong>微服务</strong></p><p><strong>为何抛弃单体应用</strong></p><ol><li>单体应用随着时间的推移会越来越臃肿，十分不利于分析代码的结构和逻辑关系</li><li>庞大的项目对于开发新功能和修复 Bug 十分耗时（焦油坑）</li><li>复杂的单体应用本身就是持续部署的障碍，启动时间过长并且容易影响其他模块</li><li>不同模块存在资源需求冲突时，单体应用难以扩展</li><li>单体应用所有应用处于同一进程中，任何模块的问题都将拖垮所有模块</li><li>单体应用使得采用新框架和语言将非常困难</li></ol><p><strong>何为微服务</strong>（水疗大法）<br>微服务架构好比一家水疗会所，<br>技师是<strong>服务提供者</strong>，你是<strong>服务消费者</strong>，水疗会所是<strong>注册中心</strong>。<br>你去水疗会所找技师，技师来提供各种服务。<br>一个技师如果不在还能换下一个技师，这就是<strong>高可用</strong>。<br>只要记住了号牌，下次还能叫这个技师，这就是<strong>缓存</strong>。<br>如果技师离职了，你所记住的号牌也就作废，这就是<strong>缓存穿透</strong>。<br>后来你没有号牌了，经理带你安排技师，这就是<strong>缓存击穿</strong>。<br>同一时间你有认识的技师都离职了，这就是<strong>缓存雪崩</strong>。<br>因为要额外安排技师，所以速度会慢一些。</p><p><strong>精髓</strong>：熔断机制（服务挂了之后返回固定的结果）<br>水疗会所只有足疗，谁问都一样，因为，<strong>警察来了</strong>。</p><p>如今常用的微服务框架解决方案有 Spring Cloud 和 Dubbo，出自 Spring 和阿里之手。<br>不过广义的来讲它俩一个是编程模型，一个是 RPC 通信框架，没什么相通点。<br><strong>技术没有好坏，只有是否合适</strong>。<br>应该根据业务来组合式的使用各种框架，没有必要去钻牛角尖的分析他们的利弊优劣。<br>比如需要做的一个<strong>对内RPC，对外REST的</strong>开发框架：<a href="https://github.com/MrTallon/SCAD-HTD" target="_blank" rel="noopener">Spring Cloud Alibaba Dubbo</a></p><p>所有微服务的开发，都在思考四个问题：</p><ol><li>多服务之间客户端如何访问</li><li>多服务之间服务端如何通信</li><li>多服务之间如何管理</li><li>多服务之间如何解决服务宕机</li></ol><p>其实，如今的微服务还没有全球统一的标准，不过很有可能是未来的 <strong>ServiceMesh</strong>（服务网格化）。</p><p>程序员也好，一家互联网企业也好，他应有<strong>四个阶段</strong>的发展过程：</p><ol><li>入门期：主要就是微服务架构的基础建设来实现项目交付</li><li>发展期：以大数据为依据进行精准营销</li><li>成熟期：大数据+人工智能的部分实现</li><li>未来规划：人工智能+区块链，全球计算机共同实现的超级计算机</li></ol><p>我现在处于第一阶段，准备向第二阶段进发。<br>如今 BAT 等大厂已经在第四阶段深耕多时，然而很多企业还没有步入第一阶段，大厂不愧为大厂啊。</p><h2 id="第二更：技术变革，思想先行"><a href="#第二更：技术变革，思想先行" class="headerlink" title="第二更：技术变革，思想先行"></a>第二更：技术变革，思想先行</h2><div style="text-align: right"> 2019.07.16 </div><p>记录最近学习微服务的一些心得。</p><p>天地无极，万法归一：<a href="https://en.wikipedia.org/wiki/Conway%27s_law" target="_blank" rel="noopener">康威定理</a></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>解决了复杂问题，在原系统功能数量不变的情况下，使个体服务更快的被开发，并更容易理解和维护</li><li>每个服务的独立开发，使得当前技术的重写旧服务变得可行</li><li>微服务架构模式可以实现每个服务独立部署，使持续部署成为可能</li><li>微服务架构模式使得每个服务可以独立扩展，可以仅部署每个满足服务的容量和可用性约束的实例条目</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>目前微服务边界不够明确</li><li>分布式系统使得整体变得复杂，模块间的互相调用都需要做相应的故障处理</li><li>分区数据库架构是一项挑战，不仅是<strong>CAP定理</strong>的限制，并且不支持如今高度扩展的 NoSQL 数据库和消息代理（分布式事务）</li><li>测试、配置、部署、扩展、监控都会很繁琐</li></ul><h3 id="CAP-定理与-BASE-理论"><a href="#CAP-定理与-BASE-理论" class="headerlink" title="CAP 定理与 BASE 理论"></a>CAP 定理与 BASE 理论</h3><h4 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h4><p>一个分布式系统，最多只能同时满足一致性、可用性和分区容错性这三项中的两项。</p><ul><li>一致性(Consistency)：更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致</li><li>可用性(Availability)：服务在正常响应时间内一直可用</li><li>分区容错性(Partition tolerance)：分布式系统在遇到某节点或网络分区故障时仍能对外提供满足一致性和可用性的服务</li></ul><h4 id="CAP-权衡"><a href="#CAP-权衡" class="headerlink" title="CAP 权衡"></a>CAP 权衡</h4><p>CP系统：金融级系统<br>AP系统：和钱无关的系统</p><h4 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h4><p>即使无法做到强一致性(Strong Consistency)，但应用可以采用适合方式达到最终一致性(Eventual Consistency)</p><ul><li>基本可用(Basically Available)：分布式系统出现故障时允许损失部分可用性，即保证核心业务可用</li><li>软状态(Soft State)：允许系统存在中间状态，该中间状态不会影响系统整体可用性。分布式存储一般一份数据至少会有三个副本，允许不同副本同步的延时就是软状态的体现（同比MySQL中 Replication 的异步复制）</li><li>最终一致性(Eventual Consistency)：系统中所有数据副本经过一段时间后最终达到一致状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况</li></ul><h4 id="ACID-和-BASE-的区别和联系"><a href="#ACID-和-BASE-的区别和联系" class="headerlink" title="ACID 和 BASE 的区别和联系"></a>ACID 和 BASE 的区别和联系</h4><p>ACID 是传统数据库常用的设计理念，追求强一致性模型。<br>BASE 支持的是大型分布式系统，提出牺牲强一致性获得高可用性。<br>在分布式系统中，系统组件对于一致性的要求是不同的，ACID 和 BASE 会结合使用。</p><h3 id="如何应对高并发"><a href="#如何应对高并发" class="headerlink" title="如何应对高并发"></a>如何应对高并发</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>高并发(High Concurrency) 是互联网分布式系统架构设计中必须考虑的因素之一。通常是指：通过设计保证系统能够同时并行处理很多请求。</p><ul><li>响应时间(Response Time)：系统对请求作出响应的时间。</li><li>吞吐量(Throughput)：单位时间内处理请求的数量</li><li>QPS(Query Per Second)：每秒响应请求数</li><li>并发用户数：同时承载正常使用系统功能的用户数量</li></ul><h4 id="提升策略"><a href="#提升策略" class="headerlink" title="提升策略"></a>提升策略</h4><h5 id="垂直扩展"><a href="#垂直扩展" class="headerlink" title="垂直扩展"></a>垂直扩展</h5><ul><li>增强单机硬件性能。如 CPU 增核，硬盘扩容等</li><li>提升单机架构性能。如使用 cache 减少 IO 次数，使用异步增强吞吐量，使用无锁数据结构来减少响应时间等</li></ul><h5 id="水平扩展（主要方法）"><a href="#水平扩展（主要方法）" class="headerlink" title="水平扩展（主要方法）"></a>水平扩展（主要方法）</h5><p><img src="https://mrtallon.gitee.io/img/architectures.jpg" alt="architecture"></p><ul><li>服务层：多机器负载均衡</li><li>数据库：分库、分表、表分区</li></ul><h2 id="第三更：蓦然回首，寂寂寥寥"><a href="#第三更：蓦然回首，寂寂寥寥" class="headerlink" title="第三更：蓦然回首，寂寂寥寥"></a>第三更：蓦然回首，寂寂寥寥</h2><div style="text-align: right"> 2019.09.27 </div><p>正值青年，回首再读鲁迅的《从百草园到三味书屋》和朱自清的《背影》，又多了不一样的感触。<br>其实我想说的是，中学的少年时代，读这些触目感怀的文章，是很难理解作者的心情的。<br>唯有离家远去，或求学，或工作，那些与家人长期分别的日子里，才能隐约体会到作者那惆怅的心境。<br>古往今来，从不缺悲戚感怀的诗人，他们应该都大抵如此罢。</p><p>不，那些优秀的散文、杂记，是可以让每个人都读到不一样的东西的。<br>少年有少年的烦恼，青年有青年的惆怅，到了中年和老年，再翻出这经典的文章，<br>怕是又能增加不少与作者共鸣的感伤了。</p><p>辗转六年，从求学，到工作，一路奔波。<br>有看文章说，三十岁前，莫回头，不要怕，尽管先前冲，去试错，去见天地；<br>三十岁后，要自省，要谨慎，去见自己。<br>按说不应该在这个朝气蓬勃的年纪去庸人自扰，但是闲来时总想无病呻吟几句。</p><p>前几天跟母亲打电话，猛然发现母上已经五十有余，顿时感到时间确实过得太快了，<br>不由想到了子欲养而亲不待，一阵后怕。<br>父亲的身体早已远不如前，去年的一场急病也甚是后怕。<br>和他们相处的时间，可能远比我想的要少了。<br>今年国庆节，本不打算回去的，可是念及于此，还是买了回家的火车票，想着能双方都有时间的假期真是不多了。<br>本打算假期一起驱车去登泰山，趁他们现在脚力尚好。<br>可是看到往年国庆假期泰山的人流和六小时的舟车颠簸，想想还是搁置了。</p><p>今年姐姐终于也是顺利毕业并有了一份稳定的工作，十分欣喜。<br>昨日在与姐姐的通话中，得知她的我的关心甚至超过对自己，十分感动。<br>不过姐姐由于多年的生活习惯和刚工作等缘故，和我有一些不同，从而让我们的对话有时不那么投机。<br>没什么好坏之分，每个人本就不同，至于哪种生活更好，见仁见智。</p><p>其实我们都是多虑了，大家应该都比看上去的样子要懂的更多，想的更远。</p><h2 id="第四更：闻窗外事，读圣贤书"><a href="#第四更：闻窗外事，读圣贤书" class="headerlink" title="第四更：闻窗外事，读圣贤书"></a>第四更：闻窗外事，读圣贤书</h2><div style="text-align: right"> 2019.10.20 </div><p>前几天无意间读到了《蜗居》的<a href="https://www.zhihu.com/question/27593812/answer/850190389?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=582459045881843712" target="_blank" rel="noopener">影评</a>,触目感怀。</p><p>「用富养的方式，将高贵的性格和忠诚的价值观，给予下一代<br>不只是所拥有钱的数量，而是要对于子女成长投入更多的关注」</p><p>其实，刺激我写下文字的原因，是影评的后半部分。</p><p>当虚伪的宋思明用作为公仆为人民服务的的特权来引诱年轻女孩寻欢作乐时，面目可憎。<br>金钱和权利的影响，在剧中无孔不入，无法回避。<br>最完美的角色，反而是美国人马克，绅士、宽容、无私的帮助女性朋友，没有企图。</p><p>月前的新加坡之行，正如许多去过的人所说，那里的基础建设，商业贸易，游戏娱乐等，是不如我国一线城市的，历史文化更是远不如中国。<br>我的第一感受也是如此。<br>不过，新加坡作为20多年发达国家，他的生产力水平，经济运行机制，国民的文化和国际化水平，我想还是高出中国不少的，这些软实力是需要在吃饱肚子的前提下耕耘多年才能培养出的意志。<br>诚然，我国用一代人的时间完成了其他国家几代人的建设，但是为此也付出了代价，此处不便细表。<br>我热爱我的祖国，在享受完发展带来的福利我也愿意去承担那不可避免的代价，但是我们还有很远的路要走，<br>除了超一线和一线，我们还有更多不那么发达的城市，国民的收入水平可能要比我想象的要低，还有很多人是得不到足够的关注。<br>希望我们的国家，能尽早培养出大量马克这样的人。我知道这是转型过程中的痛苦，我希望它快点过去。</p><p>面对剧中的腐败，不禁想到了前些天韩国艺人崔雪莉的非自然死亡。</p><p><strong>权力导致腐败，绝对的权力导致绝对地腐败。</strong><br>把权力关进笼子的最好的方法，就是表面看起来像民主和自由的样子：<br>一方阶级处于绝对的优势地位，但其他各方相对弱小的势力结合起来也可以威胁到它，这时权力就不敢作恶太过分，而大部分时间去实现它应尽的义务：管理国家，建设国家。<br>当有某一方势力强大到成为绝对势力，就会诞生崔雪莉这样的“离奇事件”。</p><p><strong>富贵不能淫，贫贱不能移。</strong><br>这里的「淫」讲的是「过度」。<br>欲望无度，永远不能被满足的时候，那就是变态。<br>富人如果不加强自身的文化素质和精神建设，就极易产生变态的欲望。<br>至于依靠那微乎其微的道德操守和品德修养，更是不靠谱。</p><p>达则兼济天下，穷则独善其身。<br>毋以善小而不为，勿以恶小而为之。<br>这些从小背熟的圣贤书，往往真的能指导我们过好一生。</p><p>在这不清不楚的环境下，我只想做个好人，做一个善良的人，尽我所能的去关心身边的人，<br>以后为子女的成长投入更多关注，减少为他人的负担，正直的走下去。</p><h2 id="第五更：乘风破浪，勇立潮头"><a href="#第五更：乘风破浪，勇立潮头" class="headerlink" title="第五更：乘风破浪，勇立潮头"></a>第五更：乘风破浪，勇立潮头</h2><div style="text-align: right"> 2019.10.27 </div><p><img src="https://mrtallon.gitee.io/img/diary2.jpeg" alt="区块链"></p><p>最近，区块链又火了。</p><p>习近平在中央政治局第十八次集体学习时强调 把<strong>区块链</strong>作为核心技术自主创新重要突破口 加快推动区块链技术和产业创新发展。</p><p>意味着我国在互联网这块又要来一波开放性政策了。</p><p>作为一名应用级开发工程师（纯调API），我真应该时刻学习，掌握架构知识了，要不然即将开始「函数即服务」，我可就没饭吃了。</p><h3 id="区块链演化："><a href="#区块链演化：" class="headerlink" title="区块链演化："></a>区块链演化：</h3><ul><li>1.0 数字货币（比特币）</li><li>2.0 智能合约（以太坊）</li><li>3.0 价值互联网</li></ul><h3 id="区块链如何解决最核心的信任问题"><a href="#区块链如何解决最核心的信任问题" class="headerlink" title="区块链如何解决最核心的信任问题"></a>区块链如何解决最核心的信任问题</h3><ol><li>去中心化</li><li>基于数学和密码学</li><li>公开透明，可追溯，不可回滚</li></ol><p>以程序的角度去看待这个问题，单点故障就是中心化，高可用就是去中心化。<br>它像是一个没有管理员，每个节点都拥有全部数据的分布式存储系统。</p><p>多地存储会出现数据一致性的问题，区块链上叫做分叉：</p><ul><li>软分叉<br>  临时分叉，当系统更新后版本差异导致分叉，版本统一后则分叉消除</li><li>硬分叉<br>  由某人或组织非法拉取的的永久分支，并号召大家认可自己的分支，如「以太坊」</li></ul><h3 id="六层模型"><a href="#六层模型" class="headerlink" title="六层模型"></a>六层模型</h3><p><img src="https://mrtallon.gitee.io/img/diary3.jpeg" alt="六层模型"></p><p>如今区块链在实际生活中有多大的应用场景呢？感觉也不多，就是一些去中心化的储存。<br>从技术的角度出发，这是一门好玩的技术，听说能开发区块链底层技术的工程师全球不超过2000人。不奢求能学会开发，只求懂得使用。<br>把以太坊作为区块链的底层系统，实现 EVM + API，称之为 <strong>DAPP</strong>，即分布式应用程序，现在多加 EAAS（区块链即服务）。<br>至此，微服务架构已是基础中的基础，扎实微服务思想后迈向区块链。</p><p>但是如今这蛮荒期，如果有人拉你去投资区块链，那基本可以拉黑处理了，近期肯定会有不少拿热点做传销的皮包公司会出来圈一波钱走人。</p><p>总之，跟党走，有肉吃。</p><h2 id="第六更：仰望星空，脚踏实地"><a href="#第六更：仰望星空，脚踏实地" class="headerlink" title="第六更：仰望星空，脚踏实地"></a>第六更：仰望星空，脚踏实地</h2><div style="text-align: right"> 2019.11.11 </div><p>光明磊落，乐于分享，目光远大</p><h2 id="第七更：新的征程，新的开始"><a href="#第七更：新的征程，新的开始" class="headerlink" title="第七更：新的征程，新的开始"></a>第七更：新的征程，新的开始</h2><div style="text-align: right"> 2020.04.17 </div><p>2020年初，一场突如其来的疫情着实打了我们一个措手不及。<br>在这危机的环境下，我辞掉了之前的工作，开启了年后找工作之旅。</p><h3 id="过程中"><a href="#过程中" class="headerlink" title="过程中"></a>过程中</h3><p>过年在家的一段时间确实轻松，<br>家是一个可以常回，但不能久待的地方。</p><p>几场面试情况也看到了自己的不足。</p><h3 id="新环境"><a href="#新环境" class="headerlink" title="新环境"></a>新环境</h3><p>新的工作环境不错，领导和同事都挺好。<br>不过工作的内容我不是特别喜欢，<br>项目技术栈老旧，代码混乱，jsp 的前端尤为不擅。</p><h2 id="第八更：无题"><a href="#第八更：无题" class="headerlink" title="第八更：无题"></a>第八更：无题</h2><div style="text-align: right"> 2020.04.20 </div><p>二叔走了，我最亲近的二叔。<br>不久我爸也走了，再也回不来了。<br>我想跟我爸走，但我爸不同意。<br>他说：世界是你们的。<br>后来有人抚养了我，自称是我三叔。<br>他说：你爸的路线是错误的，三叔有办法让家里先富起来。<br>话是这么说的，可他在卖着我家的家产。<br>再后来我家总是来客人，不是什么外国有钱人，就是我爸原来的朋友，且每次都会带点东西出去。<br>家里的仆人也混了进去，变着法的偷东西出去卖。<br>最后三叔给我找了个工作，就是给他跑腿的。<br>家里也都被各形各色的人占了，我就只分到一间地下室。<br>吃倒是比我爸那时候吃的好了，三叔总给我吹嘘这都是他的功劳。<br>可我翻来覆去想了一夜，这家本不应该就是我的吗？<br>爸爸在的时候，家里刚刚从爷爷败家后打理好，外面找债的也刚赶走，爸办起来产业也刚起步。<br>虽说穷，可活得气派，家里仆人也都疼爱着我，外人也都夸我。<br>待我长大些，把应有的都夺回来，把我爸留给我的家都夺回来。</p><p>深夜，我在地下室迷茫的幻想着。</p><div style="text-align: right"> 摘自哔哩哔哩《一步之遥》视频下评论（一小时后已被删） </div><h2 id="第九更：有一分光，发一分热"><a href="#第九更：有一分光，发一分热" class="headerlink" title="第九更：有一分光，发一分热"></a>第九更：有一分光，发一分热</h2><div style="text-align: right"> 2020.05.04 </div><p>又是一年青年节。<br>近两年我在哪款APP 上浪费的时间最多，那应该就是哔哩哔哩了。<br>B站作为年轻人的视频社区，确实有些地方做得很优秀，<br>这次青年节更是推出了优秀的宣传片<a href="https://www.bilibili.com/video/BV1FV411d7u7" target="_blank" rel="noopener">后浪</a>，制作精良。<br>可是作为B站最具特色的弹幕和评论，存在很多不一样的声音：<br>「批判该宣传片华而不实，站在不切实际的高度空谈理想、情怀，一碗毒鸡汤，只给价值观，不给方法论……」<br>并且，B站第一时间删除了一些高赞的不和谐的声音。</p><p>B站的特点是年轻人的聚集区，这是它的优势，也是它的局限。<br>掌握了年轻人才能掌握未来，而年轻人，又是最容易被煽动的群体。<br>这也就是为什么锤人会成为近期的B站特色。</p><p>说回正题，产生如此多的消极评论，正面看出了当代年轻人的压力确实挺大，<br>996的工作，看着高耸的房价却只能望而却步，从何谈起去实现理想，这个社会不允许你有理想，只能勤勤恳恳的给资本打工，满足自己的温饱，再接受一下资本的奶头乐，忘记自己应有的样子。</p><p>可是，可是，这并不是一百年前诞生的青年节的目的，我们的前辈们用鲜血发起的青年运动，是让我们去创造，去改变，去翻腾于时代的潮流。<br>而不是颓废的躺在床上满怀愤慨的去发一条戾气的弹幕或者点一个「踩」，那样只能体现出你的胆小和懦弱，习惯于温室下的环境，不堪一击。</p><p>事实上，这个视频本身就是方法论。<br>B站作为中国做的最好的视频社区网站，最好的将「分享精神」和「商业精神」结合，能够做出优秀的视频，坚持自己的风格，“恰饭”甚至是被鼓励的。<br>大家去钻研自己的兴趣特长，精心录制，大胆分享，这，就是创造。</p><p>我认为这些才是青年节应有的朝气，逆境之下依然有理想，有抱负，去为社会创造价值的前提下获得回报，不让金钱与道德相违背。年轻人应该是朝气蓬勃的人，而不是宛如鲁迅笔下祥林嫂一般“辛苦恣睢”的生活。<br>有一分光，便发一分光；有一分热，便发一分热。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;记录那些慢慢过去的，慢慢迎来的，或感怀，或心得，往复更替。&lt;br&gt;预计更新五年。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="往事" scheme="https://tallon.ink/categories/%E5%BE%80%E4%BA%8B/"/>
    
    
      <category term="废话杂谈" scheme="https://tallon.ink/tags/%E5%BA%9F%E8%AF%9D%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins</title>
    <link href="https://tallon.ink/archives/9a7f448e.html"/>
    <id>https://tallon.ink/archives/9a7f448e.html</id>
    <published>2019-02-16T03:00:30.000Z</published>
    <updated>2020-06-30T07:18:11.887Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>这个 Jenkins 的技术，一套部署下来的确是蛮抽象的，<br>但是没办法，我毕竟是要当架构师的，必须得学精通啊。</p>          </div><a id="more"></a><blockquote><p>这绝对不是一个从零开始的部署教程，只是我自己搭建下来的心得笔记，以供日后复习使用。<br>如果从未接触过 Jenkins ，建议去看更优秀的博文———<a href="http://www.funtl.com/zh/apache-dubbo-ci/%E4%BB%80%E4%B9%88%E6%98%AF-Jenkins.html" target="_blank" rel="noopener">Lusifer</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Jenkins 是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><h2 id="服务器环境配置"><a href="#服务器环境配置" class="headerlink" title="服务器环境配置"></a>服务器环境配置</h2><p>Ubutu-server 16.04-64bit</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p><code>docker-compose</code>启动 Jenkins</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jenkins:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jenkins/jenkins:lts</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:8080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">50000</span><span class="string">:50000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data:/var/jenkins_home</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data:</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 默认数据卷的位置在 <code>/var/lib/docker/volumes</code> 目录下</p></blockquote><p>解决权限问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R 1000 /var/lib/docker/volumes</span><br></pre></td></tr></table></figure><p>默认密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/docker/volumes/jenkins_data/_data/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><p>配置SSH<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "352420160@qq.com"</span><br><span class="line"></span><br><span class="line">cat .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>配置密钥</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>上传 Maven 至 /usr/local/docker/jenkins/data</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>上传 JDK 至 /usr/local/docker/jenkins/data</p><h2 id="Jenkins-配置"><a href="#Jenkins-配置" class="headerlink" title="Jenkins 配置"></a>Jenkins 配置</h2><h3 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h3><p>除推荐配置外，外加一部分必用插件</p><ol><li><p>Publish Over SSH</p></li><li><p>Dashboard View</p></li><li><p>Locale（中文界面：zh_CN）</p></li><li><p>Extended Choice Parameter (动态参数，秒级回滚)</p></li></ol><blockquote><p>所有插件重启生效</p></blockquote><h3 id="Maven-和-JDK"><a href="#Maven-和-JDK" class="headerlink" title="Maven 和 JDK"></a>Maven 和 JDK</h3><p>系统管理 -》 全局工具配置</p><p>JDK 安装</p><p>目录：/var/jenkins_home/jdk1.8.0.152</p><p>Maven</p><p>/var/jenkins_home/apache-maven-3.5.3</p><h3 id="此服务器上的-Jenkins-将应用部署到其他服务器"><a href="#此服务器上的-Jenkins-将应用部署到其他服务器" class="headerlink" title="此服务器上的 Jenkins 将应用部署到其他服务器"></a>此服务器上的 Jenkins 将应用部署到其他服务器</h3><p>系统管理 -》 系统设置</p><p>Publish over SSH</p><p>配置远端服务器信息及操作目录</p><p><strong>至此，所有环境部分搭建完毕</strong></p><hr><h2 id="GitLab-部署项目"><a href="#GitLab-部署项目" class="headerlink" title="GitLab 部署项目"></a>GitLab 部署项目</h2><h2 id="GitHub-部署项目"><a href="#GitHub-部署项目" class="headerlink" title="GitHub 部署项目"></a>GitHub 部署项目</h2><h2 id="基于-Jenkins-Pipeline-自动化部署"><a href="#基于-Jenkins-Pipeline-自动化部署" class="headerlink" title="基于 Jenkins Pipeline 自动化部署"></a>基于 Jenkins Pipeline 自动化部署</h2><p>Jenkins实现自动化部署除了上述的 Job 和每个项目中的 Pipeline 脚本，还有更极致的做法：所有项目共享一个 Pipeline 脚本，自动化部署，并实现多分支构建</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;这个 Jenkins 的技术，一套部署下来的确是蛮抽象的，&lt;br&gt;但是没办法，我毕竟是要当架构师的，必须得学精通啊。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="运维" scheme="https://tallon.ink/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Java" scheme="https://tallon.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba</title>
    <link href="https://tallon.ink/archives/647d39c3.html"/>
    <id>https://tallon.ink/archives/647d39c3.html</id>
    <published>2019-02-14T00:53:00.000Z</published>
    <updated>2019-12-17T03:35:19.294Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>练习项目：<a href="https://mrtallon.github.io/MyShop" target="_blank" rel="noopener">Spring Cloud Alibaba For MyShop</a><br>下文不是一篇教学文章，几乎没有任何操作步骤。</p>          </div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>服务限流降级</strong>：默认支持 Servlet、Feign、RestTemplate、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><strong>Sentinel</strong>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><strong>Nacos</strong>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><strong>RocketMQ</strong>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><strong>Alibaba Cloud ACM</strong>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li><strong>Alibaba Cloud OSS</strong>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><strong>Alibaba Cloud SchedulerX</strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li></ul><h2 id="开发配置"><a href="#开发配置" class="headerlink" title="开发配置"></a>开发配置</h2><h3 id="统一的依赖管理"><a href="#统一的依赖管理" class="headerlink" title="统一的依赖管理"></a>统一的依赖管理</h3><blockquote><p>当前 Spring Cloud Alibaba 的 0.2.1.RELEASE 版本基于 Spring Cloud Finchley（F）开发，故在选择 Spring Boot 版本时<strong>不要</strong>使用 2.1.0 及以上版本（因为 2.1.x 版本必须使用 Spring Cloud Greenwich，俗称 G 版），请使用官方 Demo 中使用的 2.0.6.RELEASE，以免发生意想不到的问题（比如服务无法注册到服务器）</p></blockquote><p>Spring Cloud Alibaba 项目都是基于 Spring Cloud，而 Spring Cloud 项目又是基于 Spring Boot 进行开发，并且都是使用 Maven 做项目管理工具。在实际开发中，我们一般都会创建一个依赖管理项目作为 Maven 的 Parent 项目使用，这样做可以极大的方便我们对 Jar 包版本的统一管理。</p><blockquote><p>项目的最新版本是 0.2.1.RELEASE 和 0.1.1.RELEASE，<br>版本 0.2.1.RELEASE 对应的是 Spring Cloud Finchley 版本，<br>版本 0.1.1.RELEASE 对应的是 Spring Cloud Edgware 版本。</p></blockquote><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>在 Spring Cloud Netflix 阶段采用 Eureka 做作为我们的服务注册与发现服务器，<br>现利用 Spring Cloud Alibaba 提供的 <a href="https://nacos.io/zh-cn/" target="_blank" rel="noopener">Nacos</a> 组件替代该方案。</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p><strong>服务</strong> (Service)<br>服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service.</p></li><li><p><strong>服务注册中心</strong> (Service Registry)<br>服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。</p></li><li><p><strong>服务元数据</strong> (Service Metadata)<br>服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据</p></li><li><p><strong>服务提供方</strong> (Service Provider)<br>是指提供可复用和可调用服务的应用方</p></li><li><p><strong>服务消费方</strong> (Service Consumer)<br>是指会发起对某个服务调用的应用方</p></li><li><p><strong>配置</strong> (Configuration)<br>在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。</p></li><li><p><strong>配置管理</strong> (Configuration Management)<br>在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。</p></li><li><p><strong>名字服务</strong> (Naming Service)<br>提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner/Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的2大场景。</p></li><li><p><strong>配置服务</strong> (Configuration Service)<br>在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。</p></li></ul><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>Nacos Starter 配置项信息</p><div class="table-container"><table><thead><tr><th>配置项</th><th>Key</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>服务端地址</td><td>spring.cloud.nacos.discovery.server-addr</td><td>无</td><td>Nacos Server 启动监听的ip地址和端口</td></tr><tr><td>服务名</td><td>spring.cloud.nacos.discovery.service</td><td>${spring.application.name}</td><td>给当前的服务命名</td></tr><tr><td>权重</td><td>spring.cloud.nacos.discovery.weight</td><td>1</td><td>取值范围 1 到 100，数值越大，权重越大</td></tr><tr><td>网卡名</td><td>spring.cloud.nacos.discovery.network-interface</td><td>无</td><td>当IP未配置时，注册的IP为此网卡所对应的IP地址，如果此项也未配置，则默认取第一块网卡的地址</td></tr><tr><td>注册的IP地址</td><td>spring.cloud.nacos.discovery.ip</td><td>无</td><td>优先级最高</td></tr><tr><td>注册的端口</td><td>spring.cloud.nacos.discovery.port</td><td>-1</td><td>默认情况下不用配置，会自动探测</td></tr><tr><td>命名空间</td><td>spring.cloud.nacos.discovery.namespace</td><td>无</td><td>常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</td></tr><tr><td>AccessKey</td><td>spring.cloud.nacos.discovery.access-key</td><td>无</td><td>当要上阿里云时，阿里云上面的一个云账号名</td></tr><tr><td>SecretKey</td><td>spring.cloud.nacos.discovery.secret-key</td><td>无</td><td>当要上阿里云时，阿里云上面的一个云账号密码</td></tr><tr><td>Metadata</td><td>spring.cloud.nacos.discovery.metadata</td><td>无</td><td>使用 Map 格式配置，用户可以根据自己的需要自定义一些和服务相关的元数据信息</td></tr><tr><td>日志文件名</td><td>spring.cloud.nacos.discovery.log-name</td><td>无</td><td></td></tr><tr><td>接入点</td><td>spring.cloud.nacos.discovery.enpoint</td><td>UTF-8</td><td>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</td></tr><tr><td>是否集成 Ribbon</td><td>ribbon.nacos.enabled</td><td>true</td><td>一般都设置成 true 即可</td></tr></tbody></table></div><h3 id="服务消费者（Feign）"><a href="#服务消费者（Feign）" class="headerlink" title="服务消费者（Feign）"></a>服务消费者（Feign）</h3><p>Feign 是一个声明式的伪 Http 客户端，它使得写 Http 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用 Feign 注解和 JAX-RS 注解。Feign 支持可插拔的编码器和解码器。Feign 默认集成了 Ribbon，Nacos 也很好的兼容了 Feign，默认实现了负载均衡的效果</p><ul><li>Feign 采用的是基于接口的注解</li><li>Feign 整合了 ribbon</li></ul><h3 id="熔断器防止雪崩-Sentinel"><a href="#熔断器防止雪崩-Sentinel" class="headerlink" title="熔断器防止雪崩(Sentinel)"></a>熔断器防止雪崩(Sentinel)</h3><p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以通过 RPC 相互调用，在 Spring Cloud 中可以用 RestTemplate + LoadBalanceClient 和 Feign 来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证 100% 可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的 “雪崩” 效应。</p><p>为了解决这个问题，业界提出了熔断器模型。</p><p>阿里巴巴开源了 Sentinel 组件，实现了熔断器模式，Spring Cloud 对这一组件进行了整合。在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p><p><img src="https://javasite.oss-cn-shenzhen.aliyuncs.com/blog/assets/Lusifer201805292246007.png" alt="熔断图"></p><blockquote><p>熔断器打开后，为了避免连锁故障，通过 fallback 方法可以直接返回一个固定值。</p></blockquote><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Sentinel 是阿里中间件团队研发的面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。</p><p><a href="https://yq.aliyun.com/articles/623424" target="_blank" rel="noopener">Sentinel 与 Hystrix 的对比</a></p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>丰富的应用场景： Sentinel 承接了阿里巴巴近 10 年的 双十一大促流量 的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、实时熔断下游不可用应用等。</li><li>完备的实时监控： Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li>广泛的开源生态： Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li>完善的 SPI 扩展点： Sentinel 提供简单易用、完善的 SPI 扩展点。您可以通过实现扩展点，快速的定制逻辑。例如定制规则管理、适配数据源等。</li></ul><h4 id="仪表盘监控"><a href="#仪表盘监控" class="headerlink" title="仪表盘监控"></a>仪表盘监控</h4><p>Sentinel 控制台提供一个轻量级的控制台，它提供机器发现、单机资源实时监控、集群资源汇总，以及规则管理的功能。您只需要对应用进行简单的配置，就可以使用这些功能。</p><blockquote><p>集群资源汇总仅支持 500 台以下的应用集群，有大概 1 - 2 秒的延时。</p></blockquote><h3 id="路由网关统一访问接口-Spring-Cloud-Gateway"><a href="#路由网关统一访问接口-Spring-Cloud-Gateway" class="headerlink" title="路由网关统一访问接口(Spring Cloud Gateway)"></a>路由网关统一访问接口(Spring Cloud Gateway)</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix ZUUL，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。</p><p><img src="http://www.funtl.com/assets1/3f25fcd95769a54eb391931449d5298f.jpg" alt="网关图"></p><h4 id="功能特征"><a href="#功能特征" class="headerlink" title="功能特征"></a>功能特征</h4><ul><li>基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0</li><li>动态路由</li><li>Predicates 和 Filters 作用于特定路由</li><li>集成 Hystrix 断路器</li><li>集成 Spring Cloud DiscoveryClient</li><li>易于编写的 Predicates 和 Filters</li><li>限流</li><li>路径重写</li></ul><h4 id="工程流程"><a href="#工程流程" class="headerlink" title="工程流程"></a>工程流程</h4><p><img src="http://www.funtl.com/assets1/22e4eccf2cbe09332678c04b8de98ebe.jpg" alt="网关图"></p><p>客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（pre）或之后（post）执行业务逻辑。</p><h4 id="全局过滤功能"><a href="#全局过滤功能" class="headerlink" title="全局过滤功能"></a>全局过滤功能</h4><p>全局过滤器作用于所有的路由，不需要单独配置，我们可以用它来实现很多统一化处理的业务需求，比如权限认证，IP 访问限制等等。</p><p>暂时未实现，随缘补充</p><h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。</p><h3 id="Nacos-Config"><a href="#Nacos-Config" class="headerlink" title="Nacos Config"></a>Nacos Config</h3><p>Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置。</p><p>Spring Cloud Alibaba Nacos Config 是 Spring Cloud Config Server 和 Client 的替代方案，客户端和服务器上的概念与 Spring Environment 和 PropertySource 有着一致的抽象，在特殊的 bootstrap 阶段，配置被加载到 Spring 环境中。当应用程序通过部署管道从开发到测试再到生产时，您可以管理这些环境之间的配置，并确保应用程序具有迁移时需要运行的所有内容</p><h3 id="Nacos-Config-多环境的配置"><a href="#Nacos-Config-多环境的配置" class="headerlink" title="Nacos Config 多环境的配置"></a>Nacos Config 多环境的配置</h3><p>我们在做项目开发的时候，生产环境和测试环境的一些配置可能会不一样，有时候一些功能也可能会不一样，所以我们可能会在上线的时候手工修改这些配置信息。但是 Spring 中为我们提供了 Profile 这个功能。我们只需要在启动的时候添加一个虚拟机参数，激活自己环境所要用的 Profile 就可以了。</p><p>操作起来很简单，只需要为不同的环境编写专门的配置文件，如：application-dev.yml、application-prod.yml， 启动项目时只需要增加一个命令参数 —spring.profiles.active=环境配置 即可。</p><h2 id="链路追踪-SkyWalking"><a href="#链路追踪-SkyWalking" class="headerlink" title="链路追踪(SkyWalking)"></a>链路追踪(SkyWalking)</h2><p>微服务架构是通过业务来划分服务的，使用 REST 调用。对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p><p><img src="https://javasite.oss-cn-shenzhen.aliyuncs.com/blog/assets/2279594-dd72907e82f89fd6.png" alt="链路追踪1"></p><p><img src="https://javasite.oss-cn-shenzhen.aliyuncs.com/blog/assets/2279594-4b7d1b6abe595390.png" alt="链路追踪2"></p><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>目前主要的一些 APM 工具有: Cat、Zipkin、Pinpoint、SkyWalking；Apache SkyWalking 是观察性分析平台和应用性能管理系统。提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。</p><ul><li>Skywalking Agent： 使用 JavaAgent 做字节码植入，无侵入式的收集，并通过 HTTP 或者 gRPC 方式发送数据到 SkyWalking Collector。</li><li>SkyWalking Collector： 链路数据收集器，对 agent 传过来的数据进行整合分析处理并落入相关的数据存储中。</li><li>Storage： SkyWalking 的存储，时间更迭，SW 已经开发迭代到了 6.x 版本，在 6.x 版本中支持以 ElasticSearch(支持 6.x)、Mysql、TiDB、H2、作为存储介质进行数据存储。</li><li>UI： Web 可视化平台，用来展示落地的数据。</li></ul><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><ul><li>多种监控手段，语言探针和服务网格(Service Mesh)</li><li>多语言自动探针，Java，.NET Core 和 Node.JS</li><li>轻量高效，不需要大数据</li><li>模块化，UI、存储、集群管理多种机制可选</li><li>支持告警</li><li>优秀的可视化方案</li></ul><h2 id="异步通信（RocketMQ）"><a href="#异步通信（RocketMQ）" class="headerlink" title="异步通信（RocketMQ）"></a>异步通信（RocketMQ）</h2><p>消息队列作为高并发系统的核心组件之一，能够帮助业务系统解构提升开发效率和系统稳定性。主要具有以下优势：</p><ul><li>削峰填谷： 主要解决瞬时写压力大于应用服务能力导致消息丢失、系统奔溃等问题</li><li>系统解耦： 解决不同重要程度、不同能力级别系统之间依赖导致一死全死</li><li>提升性能： 当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统</li><li>蓄流压测： 线上有些链路不好压测，可以通过堆积一定量消息再放开来压测</li></ul><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>Apache Alibaba RocketMQ 是一个消息中间件。消息中间件中有两个角色：消息生产者和消息消费者。RocketMQ 里同样有这两个概念，消息生产者负责创建消息并发送到 RocketMQ 服务器，RocketMQ 服务器会将消息持久化到磁盘，消息消费者从 RocketMQ 服务器拉取消息并提交给应用消费。</p><ul><li>支持严格的消息顺序</li><li>支持 Topic 与 Queue 两种模式</li><li>亿级消息堆积能力</li><li>比较友好的分布式特性</li><li>同时支持 Push 与 Pull 方式消费消息</li><li>历经多次天猫双十一海量消息考验</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>支持事务型消息（消息发送和 DB 操作保持两方的最终一致性，RabbitMQ 和 Kafka 不支持）</li><li>支持结合 RocketMQ 的多个系统之间数据最终一致性（多方事务，二方事务是前提）</li><li>支持 18 个级别的延迟消息（RabbitMQ 和 Kafka 不支持）</li><li>支持指定次数和时间间隔的失败消息重发（Kafka 不支持，RabbitMQ 需要手动确认）</li><li>支持 Consumer 端 Tag 过滤，减少不必要的网络传输（RabbitMQ 和 Kafka 不支持）</li><li>支持重复消费（RabbitMQ 不支持，Kafka 支持)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;练习项目：&lt;a href=&quot;https://mrtallon.github.io/MyShop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Cloud Alibaba For MyShop&lt;/a&gt;&lt;br&gt;下文不是一篇教学文章，几乎没有任何操作步骤。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="框架" scheme="https://tallon.ink/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="https://tallon.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 深度历险</title>
    <link href="https://tallon.ink/archives/afe93d88.html"/>
    <id>https://tallon.ink/archives/afe93d88.html</id>
    <published>2018-12-17T01:35:19.000Z</published>
    <updated>2019-11-20T02:14:14.061Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>MySQL 都更新到 8.0 了，系统的、完整的学习数据库。</p>          </div><a id="more"></a><h2 id="基础架构：查询语句的执行过程"><a href="#基础架构：查询语句的执行过程" class="headerlink" title="基础架构：查询语句的执行过程"></a>基础架构：查询语句的执行过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="查询"></p><p>如上图所示，MySQL大体分为Server层和存储引擎层。</p><p>5.5.5 版本后默认使用 InnoDB 引擎，也可手动选择存储引擎。</p><blockquote><p>目前已不存在查询缓存。</p></blockquote><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>负责跟客户端建立连接、获取权限、维持和管理连接,<br>当用户建立连接后，即使被管理员修改了权限，<br>也不会影响已存在权限，重连才会生效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br></pre></td></tr></table></figure><p>查看当前所有的连接及状态</p><p>当客户端建立连接后如果太长时间没动静，连接器会自动断开。</p><p>wait_timeout 控制，默认空闲时间为8小时。</p><p>长连接：连接成功后，用户的持续请求一直使用这一个连接。<br>短连接：每次执行完很少的请求就断开，下次查询重新创建。</p><p>全部使用长连接的话，有时占用内存增长特别快，因为MySQL在执行过程中使用的内存是管理在连接对象里面，这些资源在连接断开才会释放。<br>所以过多的长连接导致内存占用太大，被系统强行杀掉（OOM），也就是 MySQL 异常重启。</p><p><strong>解决方案：</strong></p><ol><li>定期断开长连接，或者判断执行一个占用内存大的查询后断开</li><li>MySQL5.7 之后，可以在比较大的查询之后，执行 mysql_reset_connection 来初始化资源</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>建立连接后开始正式执行 select 语句<br>MySQL 会先去缓存里查找近期是否有相同执行语句。</p><p>效率虽高，但大部分情况却是弊大于利：<br>当表更新时，查询缓存即失效，<br>除非是一张基本不动的静态表，如系统配置，<br>否则使用查询缓存的命中率非常低。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=DEMAND</span><br></pre></td></tr></table></figure><br>按需查找，不使用查询缓存。</p><p><strong>注：MySQL8.0之后直接将查询缓存模块删除了</strong></p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><ol><li>词法分析：识别出语句中的字符串分别代表什么</li><li>语法分析：判断上面分析出的关键词是否符合 MySQL 语法</li></ol><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>表里存在多个索引的时，判断使用哪个索引，<br>或者多表关联时决定各个表的连接顺序。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>先判断是否有该表的查询权限，没有的话返回：ERROR 1142(42000)···</p><p>执行流程：<br>​1. 调用 InnoDB 引擎接口取到表的id行，判断是否符合条件，符合条件放入结果集</p><ol><li>调用引擎接口取“下一行”，重复操作</li><li>将符合条件的结果集返回客户端</li></ol><p>数据库慢查询日志中 rows_examined 字段，表示语句执行扫描了多少行。</p><h2 id="日志系统：更新语句是如何执行的"><a href="#日志系统：更新语句是如何执行的" class="headerlink" title="日志系统：更新语句是如何执行的"></a>日志系统：更新语句是如何执行的</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> age=age+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>更新语句同查询一样，也会走一遍顶部图片的流程。<br>与查询流程不一样的是，更新操作涉及两个重要的日志模块：<br>redo log（重做日志）和binlog（归档日志）。</p><h3 id="redo-log："><a href="#redo-log：" class="headerlink" title="redo log："></a>redo log：</h3><p>如果每次更新操作都需要写进磁盘，磁盘寻找记录，随后更新，<br>那么整个IO成本、查找成本都很高。</p><p><strong>WAL：Write-Ahead Logging</strong>（先写日志，再写磁盘）</p><p>当一条记录需要更新时，InnoDB引擎会把记录写进redo log，<br>并更新内存这时更新完成。<br>同时，引擎会在空闲的时候将更新写进磁盘。<br>如果更新操作较多，则先更新部分数据，腾出地方。<br>有了redo log，InnoDB就可以保证数据发生异常重启，<br>但之前记录的数据不会丢失（crash-safe）。</p><blockquote><p>redo log 不是记录数据页“更新之后的状态”，而是记录这个页“做了什么改动”</p></blockquote><h3 id="binlog："><a href="#binlog：" class="headerlink" title="binlog："></a>binlog：</h3><p>Server 层的日志，不具备 crash-safe 功能。</p><p>binlog 有两种模式：<br>statement 格式的话是记录sql语句，<br>row 格式会记录行内容（两条），更新前和后</p><h3 id="两种日志的区别"><a href="#两种日志的区别" class="headerlink" title="两种日志的区别"></a>两种日志的区别</h3><div class="table-container"><table><thead><tr><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>InndoDB引擎特有</td><td>在 MySQL 的 Server 层实现，所有引擎都可用</td></tr><tr><td>物理日志，记录“在某个数据页上做了什么修改”</td><td>逻辑日志，记录这个语句的原始逻辑 </td></tr><tr><td>循环写的，空间固定</td><td>可以追加写入</td></tr></tbody></table></div><h3 id="更新操作内部执行流程"><a href="#更新操作内部执行流程" class="headerlink" title="更新操作内部执行流程"></a>更新操作内部执行流程</h3><ol><li>执行器先找引擎取 ID=2。ID是主键，引擎直接用树搜索这一行。</li><li>执行器拿到行数据，重新赋值，调用引擎接口将新行数据写入。</li><li>引擎将新行数据更新到内存中，同时记录redo log。<br>​    此时 redo log 处于 prepare 状态，然后告知执行器执行完成，随后提交事物。</li><li>执行器生成这个操作的binlog并写入磁盘。</li><li>执行器调用引擎的提交事物接口，redo log改成提交（commit）状态，更新完成</li></ol><p><img src="https://mrtallon.gitee.io/img/mysql03.png" alt="image-20181211133910036"></p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>redo log 的写入拆成了两个步骤：prepare 和commit，<br>是为了让两份日志之间的逻辑一致。<br>两阶段提交是跨系统维持数据逻辑一致性时常用的方案。</p><h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>简单说,事务就是保证一组数据库操作,要么全成功,要么全失败。<br>MySQL 的事物支持是在引擎层实现的。<br>MySQL 是一个支持多引擎的系统,原生 MyISAM 不支持事物。</p><h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>ACID（Atomicity,Consistency,lsolation,Durability）</p><p>当数据库多个事物同时执行的时候，<br>可能会出现脏读，不可重复读，幻读的问题，<br>由此产生“隔离级别”的概念。</p><p>正常情况下，隔离级别越高，效率越低。</p><p>SQL标准事务隔离级别：<br>读未提交，读已提交，可重复读，串行化。</p><ul><li>读未提交（read uncommitted）：一个事物还没提交时，他做的变更就能被别的事物看到</li><li>读已提交（read committed）：一个事物提交之后，他的变更才会被其他事物看到</li><li>可重复读（repeatable read）：一个事物执行过程中看到的数据，总是跟这个事物在启动时看到的数据是一致的。</li><li>串行化（serializable）：对于同一行记录，读写都会加锁，当出现读写锁冲突的时候，后访问的事物必须等前一个事物执行完成才会继续执行。</li></ul><p>在实现上，数据库会创建一个视图，访问的时候以视图结果为准。<br>可重复读时，视图是在事物启动时创建的，整个事物存在期间都用这个视图。<br>读已提交时，视图是在每个SQL语句开始执行的时候创建的。<br>读未提交时直接返回记录上的最新值，没有视图概念。<br>串行化时直接用加锁的方式来避免并行访问。</p><p><strong>Oracle 数据库默认隔离级别是”读已提交“</strong></p><p>当 Oracle 迁移 MySQL 时为保证隔离级别一致，故修改为读已提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'transaction_isolation';</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br></pre></td></tr></table></figure><h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>在 MySQL 中，每条记录在更新的时候都会同时记录一条回滚操作。<br>记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1按顺序修改成2，3，4.<br>在回滚日志里就会有如下记录</p><p><img src="https://mrtallon.gitee.io/img/mysql02.png" alt="image-20181214160942410"></p><p>当前值是4，不同时刻启动事务就会有不同的read-view。<br>在视图A、B、C里面，记录的值分别是1、2、4，<br>同一条记录在系统中可能存在多个版本，即数据库的多版本并发控制（MVCC）。<br>对于read-view A，要得到1，必须将当前的值依次执行途中所有回滚操作得到。<br>同时，当有另一个事物将4改为5，这个事物与之前的视图也不会冲突。</p><p><strong>那么，回滚日志什么时候删除？</strong><br>在不需要的时候删除，系统会判断，当没有事物需要这些回滚日志时就被删除。</p><p><strong>什么时候才算真正的不需要？</strong><br>当系统里没有比这个回滚日志更早的read-view的时候。</p><p><strong>因此，我们尽量不要使用长事物</strong></p><blockquote><p>长事物：长时间未提交的事物<br>在MySQL5.5及以前的版本，回滚日志是跟数据字典一起放在ibadata文件里，<br>即使长事物最终提交，回滚段被清理，文件也不会变小。<br>除了对回滚段的影响，长事物还占用锁资源，也可能拖垮整个库</p></blockquote><h3 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h3><ol><li>显式启动事务语句，begin或 start transaction。提交语句 commit，回滚语句 rollback。</li><li>set autocommit=0，这个命令会将当前线程自动提交关闭。意味着如果执行一个select语句，这个事务就启动了，而且不会自动提交。这个事物持续存在直到你主动执行commit或rollback，或断开连接。</li></ol><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0。<br>导致接下来的查询都在事物中，如果是长连接，就会导致意外的长事务。</p><p>因此，建议总是使用set autocommit=1来显式语句启动事务。</p><p>在 autocommit 为1的情况下，用 begin 显示启动的事务，如果执行 commit 则提交事务。<br>如果执行commit work and chain，则是提交事务并自动启动下一个事务，省去了再次执行begin语句的开销。<br>同时带来的好处是从程序开发的角度明确的知道每个语句是否在事务中。</p><p><strong>用于查询持续时间超过60秒的事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是数据库最重要的概念之一。<br>他的出现就是为提高查询效率，类似书的目录。</p><h3 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h3><p>索引的实现方式有多种，引入索引模型的概念。<br>用于提高读写效率的数据结构很多，包括哈希表，有序数组和搜索树等。</p><p>哈希表是一种以键-值（key-value）存储的数据结构，<br>哈希的思路很简单，把值放入数组，用一个哈希函数把key换算成一个确定位置，然后value放入数组的这个位置。</p><p>当多个key值经过哈希换算，会出现同一个值的情况（哈希碰撞），<br>处理这种情况的一种方法就是拉出一个链表。</p><p><strong>哈希表这种数据结构适用于只有等值查询的场景</strong>，比如 Memcached 及其他 NoSQL 引擎。</p><p>有序数组在等值查询和范围查询场景中性能更优秀。<br>它的查询效率高，但是更新的话需要挪动后面所有数据，成本太高。</p><p><strong>有序数组只适用于静态存储引擎</strong></p><p>二叉搜索树的特点：每个节点的左儿子小于父节点，父节点又小于右儿子。<br>二叉树是搜索效率最高的，但实际上大多数数据库存储并不使用二叉树。<br>因为索引不止存在内存中，还要写到磁盘上。<br>为了使查询尽量少的读磁盘，就必须让查询尽量少的访问数据块。<br>因此不应该使用二叉树，而用“N叉树”，“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，这个N差不多是1200。<br>当树高是4的时候，可以存储$1200^3$个值，17亿。<br>考虑到树根数据块总是在内存中，一个十亿行的表上的整数索引最多只需要访问3次磁盘。</p><p>其实，树的第二层也有很大概率在内存中，那么访问磁盘的次数就更少了。</p><p>N叉树由于读写上性能的优点以及适配磁盘的访问模式，被广泛应用在数据库引擎中。</p><p>数据库底层存储的核心就是基于数据模型的。<br>当遇到新数据库时需要先关注它的数据模型，才能从理论上分析它的适用场景。</p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>InnoDB 中，如果没有定义主键，它会选择一个唯一的非空索引代替。如果没有这样的索引，那么它会隐式的定义一个主键来作为聚簇索引。</p><p>索引笔记未做完，后期随缘补充</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>数据库锁设计的初衷是处理并发问题。</p><p>……</p><h2 id="实操中感受SQL优化"><a href="#实操中感受SQL优化" class="headerlink" title="实操中感受SQL优化"></a>实操中感受SQL优化</h2><h3 id="事例1"><a href="#事例1" class="headerlink" title="事例1"></a>事例1</h3><p><a href="https://mp.weixin.qq.com/s/PFTTZ79L6V9eiJi5Ygjpjg" target="_blank" rel="noopener">从30248.271s到0.001s</a></p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;MySQL 都更新到 8.0 了，系统的、完整的学习数据库。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://tallon.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Database" scheme="https://tallon.ink/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>从 Git 到 CI/CD</title>
    <link href="https://tallon.ink/archives/299e0702.html"/>
    <id>https://tallon.ink/archives/299e0702.html</id>
    <published>2018-11-16T01:45:44.000Z</published>
    <updated>2020-06-30T10:12:26.176Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>十八般武艺，浑身解数。<br>持续集成，持续交付，减少压力。</p>          </div><a id="more"></a><p><img src="https://mrtallon.gitee.io/img/git0.jpeg" alt="git02"></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li><a href="https://tallon.ink/archives/9a7f448e.html#more">Jenkins</a></li><li><a href="https://tallon.ink/archives/f5f9fa9b.html#GitLab">GitLab</a></li><li><a href="https://tallon.ink/archives/f5f9fa9b.html#Harbor">Harbor</a></li></ul><h2 id="通用脚本"><a href="#通用脚本" class="headerlink" title="通用脚本"></a>通用脚本</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>新建bin项目</p><h4 id="清理生成路径-qfdmy开头的项目"><a href="#清理生成路径-qfdmy开头的项目" class="headerlink" title="清理生成路径(qfdmy开头的项目)"></a>清理生成路径(qfdmy开头的项目)</h4><p><code>clean.bat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> [信息] 清理生成路径。</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> %~dp0</span><br><span class="line"><span class="built_in">cd</span>..</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /D %%s <span class="keyword">in</span> (qfdmy*) <span class="keyword">do</span> (</span><br><span class="line">    call mvn clean -f %%s</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h4 id="清理本地仓库"><a href="#清理本地仓库" class="headerlink" title="清理本地仓库"></a>清理本地仓库</h4><p><code>cleanlocal.bat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> [信息] 清理 Maven 本地仓库中下载失败的包。</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\apache-maven-3.6.1\repo</span><br><span class="line">rem 正在搜索...</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">"delims="</span> %%i <span class="keyword">in</span> (<span class="string">'dir /b /s "%REPOSITORY_PATH%\*lastUpdated*"'</span>) <span class="keyword">do</span> (</span><br><span class="line">    del /s /q %%i</span><br><span class="line">)</span><br><span class="line">rem 搜索完毕</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h4 id="部署项目到仓库"><a href="#部署项目到仓库" class="headerlink" title="部署项目到仓库"></a>部署项目到仓库</h4><p><code>deploy.bat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> [信息] 部署项目到仓库。</span><br><span class="line"><span class="built_in">echo</span> [注意] 如果发生异常，运行多几次即可。</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\apache-maven-3.6.1\repo\com\qfdmy</span><br><span class="line">rd /s /q %REPOSITORY_PATH%</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> %~dp0</span><br><span class="line"><span class="built_in">cd</span>..</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /D %%s <span class="keyword">in</span> (qfdmy*) <span class="keyword">do</span> (</span><br><span class="line">    call mvn deploy -f %%s</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h4 id="代码Spring化"><a href="#代码Spring化" class="headerlink" title="代码Spring化"></a>代码Spring化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> [信息] Spring 代码美化。</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> %~dp0</span><br><span class="line"><span class="built_in">cd</span>..</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /D %%s <span class="keyword">in</span> (qfdmy*) <span class="keyword">do</span> (</span><br><span class="line">    call mvn spring-javaformat:apply -f %%s</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>在每个 <code>bin</code> 项目下创建脚本</p><p><code>release.bat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">call mvn release:clean release:prepare -DignoreSnapshots=<span class="literal">true</span> release:perform</span><br><span class="line">call mvn deploy</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jre</span><br><span class="line">MAINTAINER Lusifer &lt;topsale@vip.qq.com&gt;</span><br><span class="line">ENV APP_VERSION 1.0.0.RELEASE</span><br><span class="line">RUN mkdir /app</span><br><span class="line">COPY qfdmy-all-$APP_VERSION.jar /app/app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;, &quot;--spring.profiles.active=prod&quot;]</span><br><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p><code>nginx.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip on;</span></span><br><span class="line">    gzip_static on;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code></p><p>Nginx + Vue 应用程序案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:1.19.0</span><br><span class="line">MAINTAINER Lusifer &lt;topsale@vip.qq.com&gt;</span><br><span class="line">ADD nginx.conf /etc/nginx</span><br><span class="line">ADD dist.tar.gz /usr/share/nginx/html</span><br><span class="line">EXPOSE 80 443</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;十八般武艺，浑身解数。&lt;br&gt;持续集成，持续交付，减少压力。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="后台" scheme="https://tallon.ink/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="Git" scheme="https://tallon.ink/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>清爽文本编辑 - Markdown</title>
    <link href="https://tallon.ink/archives/93ad49f7.html"/>
    <id>https://tallon.ink/archives/93ad49f7.html</id>
    <published>2018-10-17T10:46:08.000Z</published>
    <updated>2020-07-17T08:38:29.575Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>Markdown 笔记总结</p>          </div><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Markdown 是一种标记型编辑语法，最终的展示效果因渲染器的版本而定，因此有可能出现一种渲染器能够识别而另一种渲染器不识别。比如 typora 支持的 [TOC] 在 GitHub 上不支持，有道云笔记的”====”字体背景高亮在 typora 不支持等。因此对于不识别的语法我们要着重注意并尽量避开，或者对于不识别的语法进行 HTML 排版以达到想要的目的，md 的输出也以 PDF 或者 HTML 为主最好。</p><p>Markdown 的语法很多都不止一种写法，以下示例是我常用的语法规则。</p><p>注：hexo 的渲染器功能不够全面，完整事例可参考：<a href="https://mrtallon.gitee.io/out.html" target="_blank" rel="noopener">这里</a></p><hr><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol><li><p>标题语法</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一级标题#</span><br><span class="line">二级标题##</span><br><span class="line">三级标题###</span><br><span class="line">四级标题####</span><br><span class="line">五级标题#####</span><br><span class="line">六级标题######</span><br></pre></td></tr></table></figure></li><li><p>引用</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用内容</span></span><br></pre></td></tr></table></figure></li><li><p>分割线</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>删除线</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure></li><li><p>字体加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**山海**</span></span><br></pre></td></tr></table></figure></li><li><p>无序列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>Java</span><br><span class="line"><span class="bullet">- </span>C++</span><br></pre></td></tr></table></figure></li><li><p>有序列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>Pyhton</span><br><span class="line"><span class="bullet">2. </span>C#</span><br></pre></td></tr></table></figure></li><li><p>任务列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[ ] 任务1</span><br><span class="line"><span class="bullet">- </span>[ ] 任务2</span><br></pre></td></tr></table></figure><blockquote><p>列表都可以进行嵌套使用</p></blockquote></li><li><p>插入链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">外部链接</span>](<span class="link">https://tallon.ink/</span>)</span><br></pre></td></tr></table></figure></li><li><p>插入图片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">外部图片</span>](<span class="link">https://mrtallon.gitee.io/img/diary1.jpg</span>)</span><br></pre></td></tr></table></figure></li><li><p>插入表格</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|      |      |</span><br><span class="line">| ---- | ---- |</span><br><span class="line">|      |      |</span><br></pre></td></tr></table></figure></li><li><p>代码块</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码内容</span><br></pre></td></tr></table></figure></li><li><p>脚注</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我需引用脚注说明[^foot]</span><br><span class="line">[<span class="symbol">^foot</span>]:<span class="link">这里是脚注的具体内容</span></span><br></pre></td></tr></table></figure></li><li><p>目录</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure><blockquote><p>使用前请确认渲染器是否支持目录语法</p></blockquote></li></ol><hr><h2 id="初级进阶：HTML"><a href="#初级进阶：HTML" class="headerlink" title="初级进阶：HTML"></a>初级进阶：HTML</h2><ol><li><p>下划线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>泛舟沧海，立马昆仑<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span>心有敬畏，行有所止<span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>右对齐</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:right"</span>&gt;</span></span>道德经<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>字体颜色和大小</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#187892"</span> <span class="attr">size</span>=<span class="string">"number"</span>&gt;</span></span>浮舟沧海<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>颜色可选择16进制色号，也可以直接输入“red”等单词颜色，大小可以选择“+2”等与常规进行区分</p></blockquote></li></ol><blockquote><p>以上很多语法都可以组合使用，大家可自行尝试</p></blockquote><hr><h2 id="高级进阶：流程图"><a href="#高级进阶：流程图" class="headerlink" title="高级进阶：流程图"></a>高级进阶：流程图</h2><h3 id="1-横向流程图"><a href="#1-横向流程图" class="headerlink" title="1. 横向流程图"></a>1. 横向流程图</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line"></span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><h3 id="2-竖向流程图"><a href="#2-竖向流程图" class="headerlink" title="2. 竖向流程图"></a>2. 竖向流程图</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line"></span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><h3 id="3-标准流程图"><a href="#3-标准流程图" class="headerlink" title="3. 标准流程图"></a>3. 标准流程图</h3>   <div id="flowchart-0" class="flow-chart"></div>   <div id="flowchart-1" class="flow-chart"></div><h3 id="4-UML时序图"><a href="#4-UML时序图" class="headerlink" title="4. UML时序图"></a>4. UML时序图</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line"></span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line"></span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line"></span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line"></span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line"></span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line"></span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line"></span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line"></span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line"></span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line"></span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line"></span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line"></span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line"></span><br><span class="line">participant C</span><br><span class="line"></span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line"></span><br><span class="line">  sequenceDiagram</span><br><span class="line"></span><br><span class="line">    participant 张三</span><br><span class="line"></span><br><span class="line">    participant 李四</span><br><span class="line"></span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line"></span><br><span class="line">    loop 健康检查</span><br><span class="line"></span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line"></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line"></span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line"></span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line"></span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure><h3 id="5-甘特图"><a href="#5-甘特图" class="headerlink" title="5. 甘特图"></a>5. 甘特图</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line"></span><br><span class="line">        gantt</span><br><span class="line"></span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line"></span><br><span class="line">        title 软件开发甘特图</span><br><span class="line"></span><br><span class="line">        section 设计</span><br><span class="line"></span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line"></span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line"></span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line"></span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">        section 开发</span><br><span class="line"></span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line"></span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line"></span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line"></span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line"></span><br><span class="line">        耍                                   :2d</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        section 测试</span><br><span class="line"></span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line"></span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line"></span><br><span class="line">        测试报告                               : 48h    F[横向流程图]</span><br></pre></td></tr></table></figure><hr><h2 id="终极进阶：MathJax"><a href="#终极进阶：MathJax" class="headerlink" title="终极进阶：MathJax"></a>终极进阶：MathJax</h2><p>掌握基本语法，排版游刃有余</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">（这里输入要添加的公式）</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><blockquote><p>如果要在同一行输入多个公式，只需要在公式之间加上(空格)或者\quad<br>如果要输入多行公式，只需要在上一行公式的末尾加上\\</p></blockquote><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">markdown</th></tr></thead><tbody><tr><td style="text-align:center">±</td><td style="text-align:center">\pm</td></tr><tr><td style="text-align:center">×</td><td style="text-align:center">\times</td></tr><tr><td style="text-align:center">÷</td><td style="text-align:center">\div</td></tr><tr><td style="text-align:center">≤</td><td style="text-align:center">\leq</td></tr><tr><td style="text-align:center">≥</td><td style="text-align:center">\geq</td></tr><tr><td style="text-align:center">≠</td><td style="text-align:center">\neq</td></tr><tr><td style="text-align:center">⇒</td><td style="text-align:center">\Rightarrow</td></tr><tr><td style="text-align:center">⇔</td><td style="text-align:center">\Leftrightarrow</td></tr><tr><td style="text-align:center">⊂</td><td style="text-align:center">\subset</td></tr><tr><td style="text-align:center">⊆</td><td style="text-align:center">\subseteq</td></tr><tr><td style="text-align:center">∈</td><td style="text-align:center">\in</td></tr><tr><td style="text-align:center">∉</td><td style="text-align:center">\notin</td></tr><tr><td style="text-align:center">∪</td><td style="text-align:center">\cup</td></tr><tr><td style="text-align:center">∩</td><td style="text-align:center">\cap</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">\mathbb{R}</td></tr><tr><td style="text-align:center">α</td><td style="text-align:center">\alpha</td></tr><tr><td style="text-align:center">β</td><td style="text-align:center">\beta</td></tr></tbody></table></div><h3 id="函数运算符"><a href="#函数运算符" class="headerlink" title="函数运算符"></a>函数运算符</h3><div class="table-container"><table><thead><tr><th>函数</th><th>markdown</th></tr></thead><tbody><tr><td>sin(x)</td><td>\sin(x)</td></tr><tr><td>cos(x)</td><td>\cos(x)</td></tr><tr><td>tan(x)</td><td>\tan(x)</td></tr><tr><td>log2 x</td><td>\log_2 x</td></tr><tr><td>lnx</td><td>\ln x</td></tr><tr><td>lgx</td><td>\lg x</td></tr></tbody></table></div><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="部分示例表达式"><a href="#部分示例表达式" class="headerlink" title="部分示例表达式"></a>部分示例表达式</h3><ol><li><p>分式：$\frac{a}{b}$</p></li><li><p>根式</p><ol><li>$\sqrt{x}$</li><li>$\sqrt[n]{x}$</li></ol></li><li><p>上下标</p><ol><li>$x^2 $</li><li>$y_1 $</li></ol></li><li><p>向量：$\vec{a}\cdot\vec{b}=0$</p></li><li><p>均值：$\overline{x}$</p></li><li><p>极限</p><ol><li>$\lim_{n\to+\infty} n$</li><li>$\lim n$</li></ol></li><li><p>积分</p><ol><li>$\int_0^n f(x)dx$</li><li>$\int f(x)dx$</li></ol></li><li><p>累加</p><ol><li>$\sum_{i=1}^n a_i$</li><li>$\sum a_i$</li></ol></li><li><p>累乘</p><ol><li>$\prod_{i=1}^n x_i$</li><li>$\prod x_i$</li></ol></li><li><p>分段函数</p><p>$f(x)= \begin{cases} 1 &amp; x\geq 0\\ 0 &amp; x&lt;0 \end{cases}$</p></li><li><p>矩阵</p><ol><li>$X=\begin{bmatrix} 1&amp;x&amp;x^2\\\\ 1&amp;y&amp;y^2\\\\ 1&amp;z&amp;z^2 \end{bmatrix}$</li><li>$X=\left|<pre><code>\begin{matrix}    x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\    x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\    x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md}\\\end{matrix}</code></pre>\right|$</li></ol></li></ol><script type="math/tex; mode=display">\triangledown^2 g(x,y)=\frac{x^2+y^2-\sigma^2}{\sigma^4}e^{-\frac{x^2+y^2}{2\sigma^2}}</script><p>$ \operatorname{P}(dE) = \exp(\frac{dE}{kT}) $</p><hr><p>hexo 默认的 md 引不支持 MathJax，需手动开启<br>后续各自研究一下快捷键</p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">   st=>start: 开始框      op=>operation: 处理框      cond=>condition: 判断框(是或否?)      sub1=>subroutine: 子流程      io=>inputoutput: 输入输出框      e=>end: 结束框      st->op->cond      cond(yes)->io->e      cond(no)->sub1(right)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">   st=>start: 开始框      op=>operation: 处理框      cond=>condition: 判断框(是或否?)      sub1=>subroutine: 子流程      io=>inputoutput: 输入输出框      e=>end: 结束框      st(right)->op(right)->cond      cond(yes)->io(bottom)->e      cond(no)->sub1(right)->op</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;Markdown 笔记总结&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="基本功" scheme="https://tallon.ink/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="Markdown" scheme="https://tallon.ink/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Nexus</title>
    <link href="https://tallon.ink/archives/ecbf82d9.html"/>
    <id>https://tallon.ink/archives/ecbf82d9.html</id>
    <published>2018-09-24T14:44:28.000Z</published>
    <updated>2020-07-17T08:19:03.930Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>Nexus 是一个强大的仓库管理器，极大地简化了内部仓库的维护和外部仓库的访问。<br>本文先且简单的介绍Nexus信息，主要以上手操作为主，以便日后随时查阅。</p>          </div><a id="more"></a><h2 id="基于Docker安装"><a href="#基于Docker安装" class="headerlink" title="基于Docker安装"></a>基于Docker安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/docker/nexus/data &amp;&amp; chown -R 200 /usr/local/docker/nexus/data</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nexus:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sonatype/nexus3:3.23.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nexus</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">INSTALL4J_ADD_VM_PARAMS:</span> <span class="string">-XX:ActiveProcessorCount=4</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:8081</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/nexus-data</span></span><br></pre></td></tr></table></figure><blockquote><p>ActiveProcessorCount=4 是根据当前机器的内核数量决定</p></blockquote><ul><li>用户名：admin </li><li>密码：<code>cat /usr/local/docker/nexus/data/admin.password</code></li></ul><h2 id="Maven私服配置"><a href="#Maven私服配置" class="headerlink" title="Maven私服配置"></a>Maven私服配置</h2><h3 id="创建代理仓库"><a href="#创建代理仓库" class="headerlink" title="创建代理仓库"></a>创建代理仓库</h3><ul><li>点击 <code>设置按钮</code> -&gt; <code>Repository</code> -&gt; <code>Repositories</code></li><li>点击 <code>Create Repository</code> -&gt; 选择 <code>maven2 (proxy)</code> 创建 Maven 代理仓库</li><li>配置阿里云仓库代理（版本策略为 <strong>Release</strong>）<ul><li><strong>Name：</strong> <code>aliyun-nexus</code></li><li><strong>Version pollcy：</strong> <code>Release</code></li><li><strong>Remote storate：</strong> <code>http://maven.aliyun.com/nexus/content/groups/public/</code></li></ul></li><li>配置 Spring 仓库代理（版本策略为 <strong>Release</strong>）<ul><li><strong>Name：</strong> <code>spring-milestone</code></li><li><strong>Version pollcy：</strong> <code>Release</code></li><li><strong>Remote storate：</strong> <code>https://repo.spring.io/milestone</code></li></ul></li><li>配置 Spring 仓库代理（版本策略为 <strong>Snapshot</strong>）<ul><li><strong>Name：</strong> <code>spring-snapshot</code></li><li><strong>Version pollcy：</strong> <code>Snapshot</code></li><li><strong>Remote storate：</strong> <code>https://repo.spring.io/snapshot</code></li></ul></li></ul><h3 id="配置代理仓库"><a href="#配置代理仓库" class="headerlink" title="配置代理仓库"></a>配置代理仓库</h3><ul><li>点击 <code>设置按钮</code> -&gt; <code>Repository</code> -&gt; <code>Repositories</code></li><li>选择 <code>maven-public</code>，修改 <code>Group</code>（注意先后顺序）</li></ul><p><img src="http://images.qfdmy.com/Fmns_WRTVJJAhPZ_ppSbTfxzGcjt@.jpg" alt="pic"></p><h3 id="配置计划任务"><a href="#配置计划任务" class="headerlink" title="配置计划任务"></a>配置计划任务</h3><p>实际开发过程中可能每天都会产生大量的快照版本，每个快照都会占用相应的空间，历史快照版本就没有什么意义了应该定时清理以释放多占用的空间资源，我们可以通过 <strong>Tasks</strong> 计划任务选项定期清理旧的快照版本。</p><ul><li>点击 <code>设置按钮</code> -&gt; <code>System</code> -&gt; <code>Tasks</code><ul><li><strong>Task name：</strong> <code>Delete SNAPSHOT</code></li><li><strong>Repository：</strong> <code>(All Repositories)</code></li><li><strong>Minimum snapshot count：</strong> <code>1</code></li><li><strong>Snapshot retention (days)：</strong> <code>0</code></li><li><strong>Task frequency：</strong> <code>Manual</code></li></ul></li></ul><p><img src="http://images.qfdmy.com/FpzfqBajo3rINHbo8WNVa4-vAbUc@.jpg" alt="pic"></p><h3 id="配置-setting-xml"><a href="#配置-setting-xml" class="headerlink" title="配置 setting.xml"></a>配置 setting.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span></span></span><br><span class="line"><span class="tag">  </span></span><br><span class="line">&lt;mirrors&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://nexus.funtl.com/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="NPM私服配置"><a href="#NPM私服配置" class="headerlink" title="NPM私服配置"></a>NPM私服配置</h2><ul><li>点击 <code>设置按钮</code> -&gt; <code>Repository</code> -&gt; <code>Repositories</code> -&gt; <code>npm(proxy)</code><ul><li><strong>Name：</strong> npm-taobao</li><li><strong>Remote storage：</strong> <code>https://registry.npm.taobao.org</code></li></ul></li><li>点击 <code>设置按钮</code> -&gt; <code>Repository</code> -&gt; <code>Repositories</code> -&gt; <code>npm(hosted)</code><ul><li><strong>Name：</strong> npm-hosted</li></ul></li><li>点击 <code>设置按钮</code> -&gt; <code>Repository</code> -&gt; <code>Repositories</code> -&gt; <code>npm(group)</code><ul><li><strong>Name：</strong> npm-public</li></ul></li></ul><p><img src="http://images.qfdmy.com/FvSDZywnCmXEe9PW8xSV5rtBP6IG@.jpg" alt="pic"></p><h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h3><ul><li>点击 <code>设置按钮</code> -&gt; <code>Security</code> -&gt; <code>Realms</code><ul><li>将左侧 <code>npm Bearer Token Realm</code> 添加进 <code>Active</code></li></ul></li></ul><p><img src="http://images.qfdmy.com/Fg5UNZHL7aIvES9iucc4AmogRf8G@.jpg" alt="pic"></p><h3 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h3><ul><li>点击 <code>设置按钮</code> -&gt; <code>Security</code> -&gt; <code>Roles</code> -&gt; <code>Create role</code><ul><li><strong>Role ID：</strong> <code>nx-deploy</code></li><li><strong>Role name：</strong> <code>nx-deploy</code></li><li><strong>Given：</strong> <code>nx-repository-view-*-*-*</code></li></ul></li></ul><p><img src="http://images.qfdmy.com/FrORMcv7-DknuOck886m0T2hsC2k@.jpg" alt="FrORMcv7-DknuOck886m0T2hsC2k@"></p><p><img src="http://images.qfdmy.com/Fpy0W4xP484ojSiAfSNf-GIJoX8m@.jpg" alt="Fpy0W4xP484ojSiAfSNf-GIJoX8m@"></p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><ul><li>点击 <code>设置按钮</code> -&gt; <code>Security</code> -&gt; <code>Users</code> -&gt; <code>Create local user</code><ul><li><strong>ID：</strong> <code>deployer</code></li><li><strong>First name：</strong> <code>deployer</code></li><li><strong>Last name：</strong> <code>User</code></li><li><strong>Password：</strong> <code>deployer</code></li><li><strong>Roles Granted：</strong> <code>nx-deploy</code></li></ul></li></ul><p><img src="http://images.qfdmy.com/FqUwXUQVhx-D9yEDgbqNXyG8XMrM@.jpg" alt="FqUwXUQVhx-D9yEDgbqNXyG8XMrM@"></p><h3 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h3><p>修改默认仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://nexus.funtl.com/repository/npm-public/</span><br></pre></td></tr></table></figure><h3 id="修改客户端配置"><a href="#修改客户端配置" class="headerlink" title="修改客户端配置"></a>修改客户端配置</h3><p>镜像仓库配置完成后还不能直接使用，需要配置 NPM 客户端信息，修改 <code>C:\Users\用户名\.npmrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registry=http://nexus.funtl.com/repository/npm-public/</span><br><span class="line">email=topsale@vip.qq.com</span><br><span class="line">always-auth=true</span><br><span class="line">_auth=&quot;ZGVwbG95ZXI6ZGVwbG95ZXI=&quot;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> <code>_auth</code> 是 <code>username:password</code> 的 base64 值，可以通过 Linux 命令 <code>echo -n &#39;username:password&#39; | openssl base64</code> 生成。比如我们刚才的账号密码都是 <code>deployer</code> 则生成命令为：<code>echo -n &#39;deployer:deployer&#39; | openssl base64</code></p></blockquote><h2 id="将第三方-jar-包上传至-nexus"><a href="#将第三方-jar-包上传至-nexus" class="headerlink" title="将第三方 jar 包上传至 nexus"></a>将第三方 jar 包上传至 nexus</h2><blockquote><p>为方便阅读，以下代码分行展示，正式使用需合并为一行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如第三方JAR包：aliyun-sdk-oss-2.2.3.jar</span></span><br><span class="line">mvn deploy:deploy-file</span><br><span class="line"> -DgroupId=com.aliyun.oss</span><br><span class="line"> -DartifactId=aliyun-sdk-oss</span><br><span class="line"> -Dversion=2.2.3 -Dpackaging=jar </span><br><span class="line"> -Dfile=D:\aliyun-sdk-oss-2.2.3.jar</span><br><span class="line"> -Durl=http://nexus.funtl.com/repository/maven-releases/ </span><br><span class="line"> -DrepositoryId=nexus-releases</span><br></pre></td></tr></table></figure><h2 id="将第三方-jar-包上传至本地仓库"><a href="#将第三方-jar-包上传至本地仓库" class="headerlink" title="将第三方 jar 包上传至本地仓库"></a>将第三方 jar 包上传至本地仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file</span><br><span class="line"> -DgroupId=com.alibaba</span><br><span class="line"> -DartifactId=fastjson</span><br><span class="line"> -Dversion=1.1.37</span><br><span class="line"> -Dfile=D:\fastjson-2.2.3.jar</span><br><span class="line"> -Dpackageing-jar</span><br></pre></td></tr></table></figure><p><strong>Snapshots 与 Releases 的区别</strong></p><ul><li>nexus-releases: 用于发布 Release 版本(发行版)</li><li>nexus-snapshots: 用于发布 Snapshot 版本(快照版)</li><li>在项目 pom.xml 中设置的版本号添加 SNAPSHOT 标识的都会发布为 SNAPSHOT 版本，没有 SNAPSHOT 标识的都会发布为 RELEASE 版本。</li><li>SNAPSHOT 版本会自动加一个时间作为标识，如：1.0.0-SNAPSHOT 发布后为变成 1.0.0-SNAPSHOT-20180522.123456-1.jar</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;Nexus 是一个强大的仓库管理器，极大地简化了内部仓库的维护和外部仓库的访问。&lt;br&gt;本文先且简单的介绍Nexus信息，主要以上手操作为主，以便日后随时查阅。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="运维" scheme="https://tallon.ink/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Nexus" scheme="https://tallon.ink/tags/Nexus/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发</title>
    <link href="https://tallon.ink/archives/ed2e9abb.html"/>
    <id>https://tallon.ink/archives/ed2e9abb.html</id>
    <published>2018-07-25T15:06:45.000Z</published>
    <updated>2020-07-17T07:26:12.576Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>敏捷开发(Agile) 是一种以人为核心、迭代、循序渐进的开发方法。</p>          </div><a id="more"></a><p>在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。<br>简单地来说，敏捷开发并不追求前期完美的设计、完美编码，而是力求在很短的周期内开发出产品的核心功能，尽早发布出可用的版本。然后在后续的生产周期内，按照新需求不断迭代升级，完善产品。</p><h2 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h2><p><strong>个体和互动</strong>高于流程和工具<br><strong>工作的软件</strong>高于详尽的文档<br><strong>客户合作</strong>高于合同谈判<br><strong>响应变化</strong>高于遵循计划</p><h2 id="敏捷软件的十二条原则"><a href="#敏捷软件的十二条原则" class="headerlink" title="敏捷软件的十二条原则"></a>敏捷软件的十二条原则</h2><ul><li>我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。</li><li>欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。</li><li>经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。</li><li>业务人员和开发人员必须相互合作，项目中的每一天都不例外。</li><li>激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。</li><li>不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。</li><li>可工作的软件是进度的首要度量标准。</li><li>敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。</li><li>坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。</li><li>以简洁为本，它是极力减少不必要工作量的艺术。</li><li>最好的架构、需求和设计出自组织团队。</li><li>团队定期地反思如何能提高成效，并依此调整自身的举止表现。</li></ul><h2 id="敏捷开发模式的分类"><a href="#敏捷开发模式的分类" class="headerlink" title="敏捷开发模式的分类"></a>敏捷开发模式的分类</h2><p>敏捷开发的实现主要包括 SCRUM、XP(极限编程)、Crystal Methods、FDD(特性驱动开发) 等等。其中 SCRUM 与 XP 最为流行。<br>同样是敏捷开发，XP 极限编程 更侧重于实践，并力求把实践做到极限。这一实践可以是测试先行，也可以是结对编程等，关键要看具体的应用场景。<br>SCRUM 则是一种开发流程框架，也可以说是一种套路。</p><h2 id="SCRUM-的工作流程"><a href="#SCRUM-的工作流程" class="headerlink" title="SCRUM 的工作流程"></a>SCRUM 的工作流程</h2><p><strong>基本术语：</strong></p><ul><li>Sprint: 冲刺周期，通俗的讲就是实现一个“小目标”的周期。一般需要 2-6 周时间。</li><li>User Story: 用户的外在业务需求。拿银行系统来举例的话，一个 Story 可以是用户的存款行为，或者是查询余额等等。也就是所谓的小目标本身。</li><li>Task: 由 User Story 拆分成的具体开发任务。</li><li>Backlog: 需求列表，可以看成是小目标的清单。分为 Sprint Backlog 和 Product Backlog。</li><li>Daily meeting: 每天的站会，用于监控项目进度。有些公司直接称其为 Scrum。</li><li>Sprint Review meeting: 冲刺评审会议，让团队成员们演示成果。</li><li>Sprint burn down: 冲刺燃尽图，说白了就是记录当前周期的需求完成情况。</li><li>Release: 开发周期完成，项目发布新的可用版本。<br><img src="https://www.funtl.com/assets/23bbf940df9a190a229362809d735018.jpeg" alt="pic">如上图所示，在项目启动之前，会由团队的产品负责人(Product owner) 按照需求优先级来明确出一份 Product Backlog，为项目做出整体排期。<br>随后在每一个小的迭代周期里，团队会根据计划(Sprint Plan Meeting) 确定本周期的 Sprint Backlog，再细化成一个个 Task，分配给团队成员，进行具体开发工作。每一天，团队成员都会进行 Daily meeting，根据情况更新自己的 Task 状态，整个团队更新 Sprint burn down chart。<br>当这一周期的 Sprint backlog 全部完成，团队会进行 Spring review meeting，也就是评审会议。一切顺利的话，会发布出这一版本的 Release，并且进行 Sprint 回顾会议(Sprint Retrospective Meeting)。</li></ul><h2 id="XP-极限编程"><a href="#XP-极限编程" class="headerlink" title="XP 极限编程"></a>XP 极限编程</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>敏捷方法论有一个共同的特点，那就是都将矛头指向了「文档」，它们认为传统的软件工程方法文档量太「重」了，称为「重量级」方法，而相应的敏捷方法则是「轻量级」方法。正是因为「轻量级」感觉没有什么力量，不但不能够有效体现灵活性，反而显得是不解决问题的方法论似的。因此，就有了一次划时代的会议，创建了敏捷联盟。<br>在敏捷方法论领域中，比较知名的、有影响力的，是拥有与 Microsoft 的操作系统相同缩写语——XP的极限编程(eXtreme Programming)。极限编程方法论可以说是敏捷联盟中最鲜艳的一面旗帜，也是被研究、尝试、应用、赞扬、批判最多的一种方法论，也是相对来说最成熟的一种。<br>这一被誉为「黑客文化」的方法论的雏形最初形成于 1996-1999 年间，Kent Beck、Ward Cunninggham、Ron Jeffrey 在开发 C3 项目(Chrysler Comprehensive Compensation) 的实践中总结出了 XP 的基本元素。在此之后，Kent Beck 和他的一些好朋友们一起在实践中完善提高，终于形成了极限编程方法论。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>XP 是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。与其他方法论相比，其最大的不同在于：</p><ul><li>在更短的周期内，更早地提供具体、持续的反馈信息。</li><li>在迭代的进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断的发展它。</li><li>依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。</li><li>依赖于口头交流、测试和源程序进行沟通。</li><li>倡导持续的演化式设计。</li><li>依赖于开发团队内部的紧密协作。</li><li>尽可能达到程序员短期利益和项目长期利益的平衡。</li></ul><p>Kent Beck 曾经说过「开车」就是一个 XP 的范例，即使看上去进行得很顺利，也不要把视线从公路上移开，因为路况的变化，将使得你必须随时做出一些这样那样的调整。而在软件项目中，客户就是司机，他们也没有办法确切地知道软件应该做什么，因此程序员就需要向客户提供方向盘，并且告知我们现在的位置。<br>XP 由价值观、原则、实践和行为四个部分组成，它们彼此相互依赖、关联， 并通过行为贯穿于整个生命期。<br><img src="https://www.funtl.com/assets/20150924172800834" alt="pic2"></p><h3 id="四大价值"><a href="#四大价值" class="headerlink" title="四大价值"></a>四大价值</h3><p>XP 的核心是其总结的沟通(Communication)、简单(Simplicity)、反馈(Feedback)、勇气(Courage) 四大价值观，它们是XP的基础，也是XP的灵魂。</p><p><strong>沟通</strong><br>通常程序员给人留下的印象就是「内向、不善言谈」，然后项目中的许多问题就出在这些缺乏沟通的开发人员身上。经常由于某个程序员做出了一个设计决定，但是却不能及时地通知大家，结果使得大家在协作与配合上出现了很多的麻烦，而在传统的方法论中，并不在意这种口头沟通不畅的问题，而是希望借助于完善的流程和面面俱到的文档、报表、计划来替代，但是这同时又引入了效率不高的新问题。<br>XP 方法论认为，如果小组成员之间无法做到持续的、无间断的交流，那么协作就无从谈起，从这个角度能够发现，通过文档、报表等人工制品进行交流面临巨大的局限性。因此，XP 组合了诸如对编程这样的最佳实践，鼓励大家进行口头交流，通过交流解决问题，提高效率。</p><p><strong>简单</strong><br>XP 方法论提倡在工作中秉承「够用就好」的思路，也就是尽量地简单化，只要今天够用就行，不考虑明天会发现的新问题。这一点看上去十分容易，但是要真正做到保持简单的工作其实很难的。因为在传统的开发方法中，都要求大家对未来做一些预先规划，以便对今后可能发生的变化预留一些扩展的空间。<br>正如对传统开发方法的认识一样，许多开发人员也会质疑 XP，保持系统的扩展性很重要，如果都保持简单，那么如何使得系统能够有良好的扩展性呢？其实不然，保持简单的理由有两个</p><ul><li>开发小组在开发时所做的规划，并无法保证其符合客户需要的，因此做的大部分工作都将落空，使得开发过程中重复的、没有必要的工作增加，导致整体效率降低。</li><li>在 XP 中提倡时刻对代码进行重构，一直保持其良好的结构与可扩展性。也就是说，可扩展性和为明天设计并不是同一个概念，XP 是反对为明天考虑而工作，并不是说代码要失去扩展性<br>而且简单和沟通之间还有一种相对微妙的相互支持关系。当一个团队之间，沟通的越多，那么就越容易明白哪些工作需要做，哪些工作不需要做。另一方面，系统越简单，需要沟通的内容也就越少，沟通也将更加全面。</li></ul><p><strong>反馈</strong><br>是什么原因使得我们的客户、管理层这么不理解开发团队？为什么客户、管理层总是喜欢给我们一个死亡之旅？究其症结，就是开发的过程中缺乏必要的反馈。在许许多多项目中，当开发团队经历过了需求分析阶段之后，在相当长的一段时间内，是没有任何反馈信息的。整个开发过程对于客户和管理层而言就像一个黑盒子，进度完全是不可见的。<br>而且在项目的过程中，这样的现象不仅出现在开发团队与客户、管理层之间，还包括在开发团队内部。这一切问题都需要我们更加注重反馈。反馈对于任何软件项目的成功都是至关重要的，而在 XP 方法论中则更进一步，通过持续、明确的反馈来暴露软件状态的问题。具体而言就是：</p><ul><li>在开发团队内部，通过提前编写单元测试代码，时时反馈代码的问题与进展。</li><li>在开发过程中，还应该加强集成工作，做到持续集成，使得每一次增量都是一个可执行的工作版本，也就是逐渐是软件长大，整个过程中，应该通过向客户和管理层演示这些可运行的版本，以便及早地反馈，及早地发现问题。<br>同时，我们也会发现反馈与沟通也有着良好的配合，及时和良好的反馈有助于沟通。而简单的系统更有利于测试和反馈。</li></ul><p><strong>勇气</strong><br>在应用 XP 方法论时，我们每时每刻都在应对变化：<br>由于沟通良好，因此会有更多需求变更的机会；<br>由于时刻保持系统的简单，因此新的变化会带来一些重新开发的需要；<br>由于反馈及时，因此会有更多中间打断你的思路的新需求。</p><p>总之这一切，使得你立刻处于变化之中，因此这时就需要你有勇气来面对快速开发，面对可能的重新开发。<br>也许你会觉得，为什么要让我们的开发变得如此零乱，但是其实这些变化若你不让它早暴露，那么它就会迟一些出现，并不会因此消亡。因此，XP 方法论让它们早出现、早解决，是实现「小步快走」开发节奏的好办法。<br>也就是 XP 方法论要求开发人员穿上强大、自动测试的盔甲，勇往直前，在重构、编码规范的支持下，有目的地快速开发。<br>勇气可以来源于沟通，因为它使得高风险、高回报的试验成为可能；勇气可以来源于简单，因为面对简单的系统，更容易鼓起勇气；勇气可以来源于反馈，因为你可以及时获得每一步前进的状态（自动测试），会使得你更勇于重构代码。</p><h3 id="五个原则"><a href="#五个原则" class="headerlink" title="五个原则"></a>五个原则</h3><p><strong>快速反馈</strong><br>及时地、快速地获取反馈，并将所学到的知识尽快地投入到系统中去。也就是指开发人员应该通过较短的反馈循环迅速地了解现在的产品是否满足了客户的需求。这也是对反馈这一价值观的进一步补充。</p><p><strong>简单性假设</strong><br>类似地，简单性假设原则是对简单这一价值观的进一步补充。这一原则要求开发人员将每个问题都看得十分容易解决，也就是说只为本次迭代考虑，不去想未来可能需要什么，相信具有将来必要时增加系统复杂性的能力，也就是号召大家出色地完成今天的任务。</p><p><strong>逐步修改</strong><br>就像开车打方向盘一样，不要一次做出很大的改变，那样将会使得可控性变差，更适合的方法是进行微调。而在软件开发中，这样的道理同样适用，任何问题都应该通过一系列能够带来差异的微小改动来解决。</p><p><strong>提倡更改</strong><br>在软件开发过程中，最好的办法是在解决最重要问题时，保留最多选项的那个。也就是说，尽量为下一次修改做好准备。</p><p><strong>优质工作</strong><br>在实践中，经常看到许多开发人员喜欢将一些细小的问题留待后面解决。例如，界面的按钮有一些不平整，由于不影响使用就先不管；某一两个成员函数暂时没用就不先写等。这就是一种工作拖泥带水的现象，这样的坏习惯一旦养成，必然使得代码质量大打折扣。<br>而在 XP 方法论中，贯彻的是“小步快走”的开发原则，因此工作质量决不可打折扣，通常采用测试先行的编码方式来提供支持。</p><h2 id="淘宝的敏捷历程"><a href="#淘宝的敏捷历程" class="headerlink" title="淘宝的敏捷历程"></a>淘宝的敏捷历程</h2><p>在业务方向明确的情况下，按照业务单元组建特性团队是最理想的选择。在业务方向不明朗的情况下，可以先组建无限制特性团队，再逐步过渡到业务单元特性团队。无论采用何种组织设计，目的都是快速跑通业务闭环：持续地交付业务价值，并在真正的市场环境中检验假设，通过快速试错找到在一定的利润水平上为企业或终端用户提供产品和服务的可行方法。</p><div style="text-align: right"> ———— 问菊（阿里巴巴敏捷教练） </div><h2 id="敏捷开发与-DevOps"><a href="#敏捷开发与-DevOps" class="headerlink" title="敏捷开发与 DevOps"></a>敏捷开发与 DevOps</h2><p>DevOps 是 Development 和 Operations 的合成词，其目标是要加强开发人员、测试人员、运维人员之间的沟通协调。需要我们的项目做到持续集成、持续交付、持续部署。<br>时下流行的 Jenkins、Bamboo，就是两款优秀的持续集成工具。而 Docker 容器则为 DevOps 提供了强大而有效的统一环境。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>敏捷开发作为一种开发模式，其主要作用还是服务于业务，帮助团队快速、高质量的产出代码。<br>而不能为敏捷而敏捷，那终将只学得形似，感受不到敏捷真正的驱动力。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;敏捷开发(Agile) 是一种以人为核心、迭代、循序渐进的开发方法。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="Agile" scheme="https://tallon.ink/categories/Agile/"/>
    
    
      <category term="敏捷开发" scheme="https://tallon.ink/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://tallon.ink/archives/f5f9fa9b.html"/>
    <id>https://tallon.ink/archives/f5f9fa9b.html</id>
    <published>2018-07-22T18:40:18.000Z</published>
    <updated>2020-11-22T17:28:44.443Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>一次构建，到处运行</p>          </div><a id="more"></a><p>本文先且简单的介绍 Docker 信息，主要以上手操作为主，以便日后随时查阅。</p><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p><h2 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><h3 id="1-更高效的利用系统资源"><a href="#1-更高效的利用系统资源" class="headerlink" title="1.更高效的利用系统资源"></a>1.更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h3 id="2-更快速的启动时间"><a href="#2-更快速的启动时间" class="headerlink" title="2.更快速的启动时间"></a>2.更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="3-一致的运行环境"><a href="#3-一致的运行环境" class="headerlink" title="3.一致的运行环境"></a>3.一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="4-持续交付和部署"><a href="#4-持续交付和部署" class="headerlink" title="4.持续交付和部署"></a>4.持续交付和部署</h3><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p><p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="5-更轻松的迁移"><a href="#5-更轻松的迁移" class="headerlink" title="5.更轻松的迁移"></a>5.更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="6-更轻松的维护和扩展"><a href="#6-更轻松的维护和扩展" class="headerlink" title="6.更轻松的维护和扩展"></a>6.更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker 划分为 CE 和 EE。<br>CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。</p><p>Docker CE 每月发布一个 Edge 版本 (17.03, 17.04, 17.05…)，<br>每三个月发布一个 Stable 版本 (17.03, 17.06, 17.09…)，<br>Docker EE 和 Stable 版本号保持一致，但每个版本提供一年维护。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装指南</a>，这里主要介绍 Docker CE 在 Linux macOS 上的安装。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>由于种种历史遗留原因，国内服务器的Ubuntu使用很少。<br>Centos 是 Red Hat 旗下的，只有国内用，<br>国际上唯 Ubuntu 马首是瞻，建议大家尽早熟悉 Ubuntu 系统。</p><h4 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h4><ol><li><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker-engine</span><br></pre></td></tr></table></figure></li><li><p>安装docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure></li><li><p>开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li></ol><h4 id="Ubuntu-16-04"><a href="#Ubuntu-16-04" class="headerlink" title="Ubuntu(16.04+)"></a>Ubuntu(16.04+)</h4><ol><li><p>清理资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">docker system prune --all --volumes</span><br></pre></td></tr></table></figure></li><li><p>卸载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt remove docker.io</span><br></pre></td></tr></table></figure></li><li><p>安装新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install docker.io</span><br></pre></td></tr></table></figure></li><li><p>验证安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></li></ol><h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><ol><li><p>配置阿里镜像(满足k8s建议): <code>vim /etc/docker/daemon.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>],</span><br><span class="line">  <span class="attr">"log-driver"</span>: <span class="string">"json-file"</span>,</span><br><span class="line">  <span class="attr">"log-opts"</span>: &#123;</span><br><span class="line">    <span class="attr">"max-size"</span>: <span class="string">"100m"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://1eto9wi5.mirror.aliyuncs.com/"</span>,</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"storage-driver"</span>: <span class="string">"overlay2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p><p><a href="http://get.daocloud.io/#install-compose" target="_blank" rel="noopener">国内镜像</a></p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>现在 Mac 和 Windows 环境推荐安装桌面版的 Docker，已经自动集成 docker-compose。</p><p>在 Mac 环境使用docker-compose 启动项目时报错，没有将文件夹分享到 Docker。<br>通过设置 Docker-Desktop 的 File Shareing 解决。</p><h2 id="镜像实战"><a href="#镜像实战" class="headerlink" title="镜像实战"></a>镜像实战</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="5-X"><a href="#5-X" class="headerlink" title="5.X"></a>5.X</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.22</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="string">--collation-server=utf8mb4_general_ci</span></span><br><span class="line">      <span class="string">--explicit_defaults_for_timestamp=true</span></span><br><span class="line">      <span class="string">--lower_case_table_names=1</span></span><br><span class="line">      <span class="string">--max_allowed_packet=128M</span></span><br><span class="line">      <span class="string">--sql-mode="STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/mysql/data:/var/lib/mysql</span></span><br></pre></td></tr></table></figure><h4 id="8-X"><a href="#8-X" class="headerlink" title="8.X"></a>8.X</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0.20</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="string">--collation-server=utf8mb4_general_ci</span></span><br><span class="line">      <span class="string">--explicit_defaults_for_timestamp=true</span></span><br><span class="line">      <span class="string">--lower_case_table_names=1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/mysql</span></span><br><span class="line">  <span class="comment">#MySQL的web客户端</span></span><br><span class="line">  <span class="attr">adminer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">adminer</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3305</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="开启高可用的哨兵模式集群部署"><a href="#开启高可用的哨兵模式集群部署" class="headerlink" title="开启高可用的哨兵模式集群部署"></a>开启高可用的哨兵模式集群部署</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">master:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-master</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">slave1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-slave-1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6380</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--slaveof</span> <span class="string">redis-master</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">slave2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-slave-2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6381</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--slaveof</span> <span class="string">redis-master</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><h4 id="搭建Sentinel集群"><a href="#搭建Sentinel集群" class="headerlink" title="搭建Sentinel集群"></a>搭建Sentinel集群</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sentinel1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-sentinel-1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">26379</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-sentinel</span> <span class="string">/usr/local/etc/redis/sentinel.conf</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./sentinel1.conf:/usr/local/etc/redis/sentinel.conf</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">sentinel2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-sentinel-2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">26380</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-sentinel</span> <span class="string">/usr/local/etc/redis/sentinel.conf</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./sentinel2.conf:/usr/local/etc/redis/sentinel.conf</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">sentinel3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-sentinel-3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">26381</span><span class="string">:26379</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-sentinel</span> <span class="string">/usr/local/etc/redis/sentinel.conf</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./sentinel3.conf:/usr/local/etc/redis/sentinel.conf</span></span><br></pre></td></tr></table></figure><p>需要三份 sentinel.conf 配置文件，分别为 sentinel1.conf，sentinel2.conf，sentinel3.conf，配置文件内容相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line"># 自定义集群名，其中 127.0.0.1 为 redis-master 的 ip，6379 为 redis-master 的端口，2 为最小投票数（因为有 3 台 Sentinel 所以可以设置成 2）</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br></pre></td></tr></table></figure><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.3'</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data_config:/data/config</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"27017:27017"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><blockquote><p>同级目录下创建 data 和 data_config 文件夹并赋权，mac 系统需同时将 mongo 文件夹添加至 share file</p></blockquote><p><strong>新建数用户并测试连接</strong></p><ol><li><p>使用 admin 登陆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongoName mongo admin</span><br></pre></td></tr></table></figure></li><li><p>创建最高权限用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: &apos;admin&apos;, pwd: &apos;admin&apos;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125;);</span><br></pre></td></tr></table></figure></li><li><p>尝试使用上面创建的用户信息进行连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.auth(&apos;admin&apos;, &apos;admin&apos;)</span><br></pre></td></tr></table></figure></li><li><p>测试连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br><span class="line">use admin</span><br></pre></td></tr></table></figure></li><li><p>显示表列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show collections</span><br></pre></td></tr></table></figure></li><li><p>格式化显示 city 表中的数据（city存在）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.city.find().pretty()</span><br></pre></td></tr></table></figure></li></ol><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><a href="https://tallon.ink/archives/65b69107.html#more">Nginx</a></h3><h3 id="Nexus"><a href="#Nexus" class="headerlink" title="Nexus"></a><a href="https://tallon.ink/2018/09/24/Nexus/">Nexus</a></h3><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><a href="https://tallon.ink/archives/9a7f448e.html">Jenkins</a></h3><h3 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">'twang2218/gitlab-ce-zh:11.1.4'</span></span><br><span class="line">      <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">      <span class="attr">hostname:</span> <span class="string">'gitlab.funtl.com'</span></span><br><span class="line">      <span class="attr">container_name:</span> <span class="string">'gitlab'</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line">        <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">external_url</span> <span class="string">'http://gitlab.funtl.com'</span></span><br><span class="line">          <span class="string">gitlab_rails['gitlab_shell_ssh_port']</span> <span class="string">=</span> <span class="number">2222</span></span><br><span class="line">          <span class="string">unicorn['port']</span> <span class="string">=</span> <span class="number">8888</span></span><br><span class="line">          <span class="string">nginx['listen_port']</span> <span class="string">=</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'80:80'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'443:443'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'2222:22'</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./config:/etc/gitlab</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./data:/var/opt/gitlab</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./logs:/var/log/gitlab</span></span><br></pre></td></tr></table></figure><h3 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab Runner"></a>GitLab Runner</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">gitlab-runner:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">environment</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitlab-runner</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config:/etc/gitlab-runner</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:6.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"cluster.name=elasticsearch"</span> <span class="comment">#设置集群名称为elasticsearch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"discovery.type=single-node"</span> <span class="comment">#以单一节点模式启动</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span> <span class="comment">#设置使用jvm内存大小</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins</span> <span class="comment">#插件文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mydata/elasticsearch/data:/usr/share/elasticsearch/data</span> <span class="comment">#数据文件挂载</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure><h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5000</span><span class="string">:5000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/registry/data:/var/lib/registry</span></span><br></pre></td></tr></table></figure><h3 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h3><p>提升用户使用 Registry 构建和运行环境传输镜像的效率。</p><p>有时<strong>墙</strong>的原因，推荐使用本地安装。</p><p><a href="">harbor</a></p><ol><li><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v1.8.0.tgz</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim harbor.yml</span><br><span class="line">hostname:42.56.89.59</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure></li><li><p>登录信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin</span><br><span class="line">Harbor12345</span><br></pre></td></tr></table></figure></li></ol><p><strong>配置客户端 </strong><code>vim /etc/docker/daemon.json</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"insecure-registries":[</span><br><span class="line">  <span class="string">"42.56.89.59"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>进入/退出容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it id /bin/bash</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>折腾我一天的问题：限制容器启动内存<br>run：<br>-e ES_JAVA_OPTS=”-Xms256m -Xmx256m”</p><p>docker-compose 2.X<br>mem_limit: 256M</p><p>docker-compose 3.X<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpus:</span> <span class="string">'0.001'</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">50M</span></span><br><span class="line">    <span class="attr">reservations:</span></span><br><span class="line">      <span class="attr">cpus:</span> <span class="string">'0.0001'</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">20M</span></span><br></pre></td></tr></table></figure><br>在 3.X 时总是没有成功限制启动内存，因为不兼容<br>docker-compose —compatibility up -d<br>这样启动即可<br>参考文档<br><a href="https://nickjanetakis.com/blog/docker-tip-78-using-compatibility-mode-to-set-memory-and-cpu-limits" target="_blank" rel="noopener">Using Compatibility Mode to Set Memory and CPU Limits</a><br><a href="https://stackoverflow.com/questions/42457889/limit-useable-host-resources-in-docker-compose-without-swarm?r=SearchResults" target="_blank" rel="noopener"><a href="https://stackoverflow.com/questions/42457889/limit-useable-host-resources-in-docker-compose-without-swarm" target="_blank" rel="noopener">Limit useable host resources in Docker compose without swarm</a></a></p><h2 id="一次构建，到处运行"><a href="#一次构建，到处运行" class="headerlink" title="一次构建，到处运行"></a>一次构建，到处运行</h2><p>感觉这就是 Docker 的精髓了</p><h3 id="创建私服"><a href="#创建私服" class="headerlink" title="创建私服"></a>创建私服</h3><p>存放自己的 Docker 镜像并且创建web页面</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5000</span><span class="string">:5000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/registry/data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">konradkleine/docker-registry-frontend:v2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8083</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./certs/frontend.crt:/etc/apache2/server.crt:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./certs/frontend.key:/etc/apache2/server.key:ro</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENV_DOCKER_REGISTRY_HOST=192.168.75.133</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENV_DOCKER_REGISTRY_PORT=5000</span></span><br></pre></td></tr></table></figure><h3 id="私服客户端vim-etc-docker-daemon-json"><a href="#私服客户端vim-etc-docker-daemon-json" class="headerlink" title="私服客户端vim /etc/docker/daemon.json"></a>私服客户端<code>vim /etc/docker/daemon.json</code></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"42.56.89.59:5000"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><br>前端页面：<code>ip:8083</code></p><h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><p>安装git拉取项目,配置jdk和maven等基础环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">maven环境变量</span><br><span class="line"></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export M2_HOME=/usr/local/maven/apache-maven-3.6.1</span><br><span class="line">export M2=$M2_HOME/bin</span><br><span class="line">export PATH=$M2:$PATH</span><br><span class="line"></span><br><span class="line">使用户环境变量生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>打包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure></p><h3 id="构建部署"><a href="#构建部署" class="headerlink" title="构建部署"></a>构建部署</h3><p>本节已创建完整代码案例，具体操作详解<a href="https://github.com/MrTallon/easy/tree/master/docker" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;一次构建，到处运行&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="运维" scheme="https://tallon.ink/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="https://tallon.ink/tags/Docker/"/>
    
  </entry>
  
</feed>
